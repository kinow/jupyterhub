

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>Configuration Reference &#8212; JupyterHub 1.2.0dev documentation</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Administrator’s Guide" href="../index-admin.html" />
    <link rel="prev" title="Run JupyterHub without root privileges using sudo" href="config-sudo.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    
    <a class="navbar-brand" href="../index.html">
      <img src="../_static/logo.png" class="logo" alt="logo">
    </a>
    
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../installation-guide.html">Installation</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../getting-started/index.html">Get Started</a>
        </li>
        
        <li class="nav-item active">
            <a class="nav-link" href="index.html">Technical Reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../index-admin.html">Administrator’s Guide</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../api/index.html">JupyterHub API</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../contributing/index.html">Contributing</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../index-about.html">About</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar">

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>


<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

  <div class="bd-toc-item active">
  

  <ul class="nav bd-sidenav">
      
      
      
      
      
      
        
          
              <li class="">
                  <a href="technical-overview.html">Technical Overview</a>
              </li>
          
        
          
              <li class="">
                  <a href="urls.html">JupyterHub URL scheme</a>
              </li>
          
        
          
              <li class="">
                  <a href="websecurity.html">Security Overview</a>
              </li>
          
        
          
              <li class="">
                  <a href="authenticators.html">Authenticators</a>
              </li>
          
        
          
              <li class="">
                  <a href="spawners.html">Spawners</a>
              </li>
          
        
          
              <li class="">
                  <a href="services.html">Services</a>
              </li>
          
        
          
              <li class="">
                  <a href="proxy.html">Writing a custom Proxy implementation</a>
              </li>
          
        
          
              <li class="">
                  <a href="separate-proxy.html">Running proxy separately from the hub</a>
              </li>
          
        
          
              <li class="">
                  <a href="rest.html">Using JupyterHub’s REST API</a>
              </li>
          
        
          
              <li class="">
                  <a href="database.html">The Hub’s Database</a>
              </li>
          
        
          
              <li class="">
                  <a href="templates.html">Working with templates and UI</a>
              </li>
          
        
          
              <li class="">
                  <a href="../events/index.html">Eventlogging and Telemetry</a>
              </li>
          
        
          
              <li class="">
                  <a href="config-user-env.html">Configuring user environments</a>
              </li>
          
        
          
              <li class="">
                  <a href="config-examples.html">Configuration examples</a>
              </li>
          
        
          
              <li class="">
                  <a href="config-ghoauth.html">Configure GitHub OAuth</a>
              </li>
          
        
          
              <li class="">
                  <a href="config-proxy.html">Using a reverse proxy</a>
              </li>
          
        
          
              <li class="">
                  <a href="config-sudo.html">Run JupyterHub without root privileges using sudo</a>
              </li>
          
        
          
              <li class="active">
                  <a href="">Configuration Reference</a>
              </li>
          
        
      
      
      
      
      
      
      
      
      
      
    </ul>

</nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#jupyterhub-configuration" class="nav-link">JupyterHub configuration</a>
        </li>
    
        <li class="nav-item toc-entry toc-h2">
            <a href="#jupyterhub-help-command-output" class="nav-link">JupyterHub help command output</a>
        </li>
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="configuration-reference">
<h1>Configuration Reference<a class="headerlink" href="#configuration-reference" title="Permalink to this headline">¶</a></h1>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Make sure the version of JupyterHub for this documentation matches your
installation version, as the output of this command may change between versions.</p>
</div>
<div class="section" id="jupyterhub-configuration">
<h2>JupyterHub configuration<a class="headerlink" href="#jupyterhub-configuration" title="Permalink to this headline">¶</a></h2>
<p>As explained in the <a class="reference external" href="../getting-started/config-basics.html#generate-a-default-config-file">Configuration Basics</a>
section, the <code class="docutils literal notranslate"><span class="pre">jupyterhub-config.py</span></code> can be automatically generated via</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>jupyterhub --generate-config
</pre></div>
</div>
</div></blockquote>
<p>The following contains the output of that command for reference.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Configuration file for jupyterhub.</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Application(SingletonConfigurable) configuration</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="c1">## This is an application.</span>

<span class="c1">## The date format used by logging formatters for %(asctime)s</span>
<span class="c1">#c.Application.log_datefmt = &#39;%Y-%m-%d %H:%M:%S&#39;</span>

<span class="c1">## The Logging format template</span>
<span class="c1">#c.Application.log_format = &#39;[%(name)s]%(highlevel)s %(message)s&#39;</span>

<span class="c1">## Set the log level by value or name.</span>
<span class="c1">#c.Application.log_level = 30</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># JupyterHub(Application) configuration</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="c1">## An Application for starting a Multi-User Jupyter Notebook server.</span>

<span class="c1">## Maximum number of concurrent servers that can be active at a time.</span>
<span class="c1">#  </span>
<span class="c1">#  Setting this can limit the total resources your users can consume.</span>
<span class="c1">#  </span>
<span class="c1">#  An active server is any server that&#39;s not fully stopped. It is considered</span>
<span class="c1">#  active from the time it has been requested until the time that it has</span>
<span class="c1">#  completely stopped.</span>
<span class="c1">#  </span>
<span class="c1">#  If this many user servers are active, users will not be able to launch new</span>
<span class="c1">#  servers until a server is shutdown. Spawn requests will be rejected with a 429</span>
<span class="c1">#  error asking them to try again.</span>
<span class="c1">#  </span>
<span class="c1">#  If set to 0, no limit is enforced.</span>
<span class="c1">#c.JupyterHub.active_server_limit = 0</span>

<span class="c1">## Duration (in seconds) to determine the number of active users.</span>
<span class="c1">#c.JupyterHub.active_user_window = 1800</span>

<span class="c1">## Resolution (in seconds) for updating activity</span>
<span class="c1">#  </span>
<span class="c1">#  If activity is registered that is less than activity_resolution seconds more</span>
<span class="c1">#  recent than the current value, the new value will be ignored.</span>
<span class="c1">#  </span>
<span class="c1">#  This avoids too many writes to the Hub database.</span>
<span class="c1">#c.JupyterHub.activity_resolution = 30</span>

<span class="c1">## Grant admin users permission to access single-user servers.</span>
<span class="c1">#  </span>
<span class="c1">#  Users should be properly informed if this is enabled.</span>
<span class="c1">#c.JupyterHub.admin_access = False</span>

<span class="c1">## DEPRECATED since version 0.7.2, use Authenticator.admin_users instead.</span>
<span class="c1">#c.JupyterHub.admin_users = set()</span>

<span class="c1">## Allow named single-user servers per user</span>
<span class="c1">#c.JupyterHub.allow_named_servers = False</span>

<span class="c1">## Answer yes to any questions (e.g. confirm overwrite)</span>
<span class="c1">#c.JupyterHub.answer_yes = False</span>

<span class="c1">## PENDING DEPRECATION: consider using services</span>
<span class="c1">#  </span>
<span class="c1">#  Dict of token:username to be loaded into the database.</span>
<span class="c1">#  </span>
<span class="c1">#  Allows ahead-of-time generation of API tokens for use by externally managed</span>
<span class="c1">#  services, which authenticate as JupyterHub users.</span>
<span class="c1">#  </span>
<span class="c1">#  Consider using services for general services that talk to the JupyterHub API.</span>
<span class="c1">#c.JupyterHub.api_tokens = {}</span>

<span class="c1">## Authentication for prometheus metrics</span>
<span class="c1">#c.JupyterHub.authenticate_prometheus = True</span>

<span class="c1">## Class for authenticating users.</span>
<span class="c1">#  </span>
<span class="c1">#          This should be a subclass of :class:`jupyterhub.auth.Authenticator`</span>
<span class="c1">#  </span>
<span class="c1">#          with an :meth:`authenticate` method that:</span>
<span class="c1">#  </span>
<span class="c1">#          - is a coroutine (asyncio or tornado)</span>
<span class="c1">#          - returns username on success, None on failure</span>
<span class="c1">#          - takes two arguments: (handler, data),</span>
<span class="c1">#            where `handler` is the calling web.RequestHandler,</span>
<span class="c1">#            and `data` is the POST form data from the login page.</span>
<span class="c1">#  </span>
<span class="c1">#          .. versionchanged:: 1.0</span>
<span class="c1">#              authenticators may be registered via entry points,</span>
<span class="c1">#              e.g. `c.JupyterHub.authenticator_class = &#39;pam&#39;`</span>
<span class="c1">#  </span>
<span class="c1">#  Currently installed: </span>
<span class="c1">#    - default: jupyterhub.auth.PAMAuthenticator</span>
<span class="c1">#    - dummy: jupyterhub.auth.DummyAuthenticator</span>
<span class="c1">#    - pam: jupyterhub.auth.PAMAuthenticator</span>
<span class="c1">#c.JupyterHub.authenticator_class = &#39;jupyterhub.auth.PAMAuthenticator&#39;</span>

<span class="c1">## The base URL of the entire application.</span>
<span class="c1">#  </span>
<span class="c1">#  Add this to the beginning of all JupyterHub URLs. Use base_url to run</span>
<span class="c1">#  JupyterHub within an existing website.</span>
<span class="c1">#  </span>
<span class="c1">#  .. deprecated: 0.9</span>
<span class="c1">#      Use JupyterHub.bind_url</span>
<span class="c1">#c.JupyterHub.base_url = &#39;/&#39;</span>

<span class="c1">## The public facing URL of the whole JupyterHub application.</span>
<span class="c1">#  </span>
<span class="c1">#  This is the address on which the proxy will bind. Sets protocol, ip, base_url</span>
<span class="c1">#c.JupyterHub.bind_url = &#39;http://:8000&#39;</span>

<span class="c1">## Whether to shutdown the proxy when the Hub shuts down.</span>
<span class="c1">#  </span>
<span class="c1">#  Disable if you want to be able to teardown the Hub while leaving the proxy</span>
<span class="c1">#  running.</span>
<span class="c1">#  </span>
<span class="c1">#  Only valid if the proxy was starting by the Hub process.</span>
<span class="c1">#  </span>
<span class="c1">#  If both this and cleanup_servers are False, sending SIGINT to the Hub will</span>
<span class="c1">#  only shutdown the Hub, leaving everything else running.</span>
<span class="c1">#  </span>
<span class="c1">#  The Hub should be able to resume from database state.</span>
<span class="c1">#c.JupyterHub.cleanup_proxy = True</span>

<span class="c1">## Whether to shutdown single-user servers when the Hub shuts down.</span>
<span class="c1">#  </span>
<span class="c1">#  Disable if you want to be able to teardown the Hub while leaving the single-</span>
<span class="c1">#  user servers running.</span>
<span class="c1">#  </span>
<span class="c1">#  If both this and cleanup_proxy are False, sending SIGINT to the Hub will only</span>
<span class="c1">#  shutdown the Hub, leaving everything else running.</span>
<span class="c1">#  </span>
<span class="c1">#  The Hub should be able to resume from database state.</span>
<span class="c1">#c.JupyterHub.cleanup_servers = True</span>

<span class="c1">## Maximum number of concurrent users that can be spawning at a time.</span>
<span class="c1">#  </span>
<span class="c1">#  Spawning lots of servers at the same time can cause performance problems for</span>
<span class="c1">#  the Hub or the underlying spawning system. Set this limit to prevent bursts of</span>
<span class="c1">#  logins from attempting to spawn too many servers at the same time.</span>
<span class="c1">#  </span>
<span class="c1">#  This does not limit the number of total running servers. See</span>
<span class="c1">#  active_server_limit for that.</span>
<span class="c1">#  </span>
<span class="c1">#  If more than this many users attempt to spawn at a time, their requests will</span>
<span class="c1">#  be rejected with a 429 error asking them to try again. Users will have to wait</span>
<span class="c1">#  for some of the spawning services to finish starting before they can start</span>
<span class="c1">#  their own.</span>
<span class="c1">#  </span>
<span class="c1">#  If set to 0, no limit is enforced.</span>
<span class="c1">#c.JupyterHub.concurrent_spawn_limit = 100</span>

<span class="c1">## The config file to load</span>
<span class="c1">#c.JupyterHub.config_file = &#39;jupyterhub_config.py&#39;</span>

<span class="c1">## DEPRECATED: does nothing</span>
<span class="c1">#c.JupyterHub.confirm_no_ssl = False</span>

<span class="c1">## Number of days for a login cookie to be valid. Default is two weeks.</span>
<span class="c1">#c.JupyterHub.cookie_max_age_days = 14</span>

<span class="c1">## The cookie secret to use to encrypt cookies.</span>
<span class="c1">#  </span>
<span class="c1">#  Loaded from the JPY_COOKIE_SECRET env variable by default.</span>
<span class="c1">#  </span>
<span class="c1">#  Should be exactly 256 bits (32 bytes).</span>
<span class="c1">#c.JupyterHub.cookie_secret = b&#39;&#39;</span>

<span class="c1">## File in which to store the cookie secret.</span>
<span class="c1">#c.JupyterHub.cookie_secret_file = &#39;jupyterhub_cookie_secret&#39;</span>

<span class="c1">## The location of jupyterhub data files (e.g. /usr/local/share/jupyterhub)</span>
<span class="c1">#c.JupyterHub.data_files_path = &#39;$HOME/Development/python/workspace/jupyterhub/share/jupyterhub&#39;</span>

<span class="c1">## Include any kwargs to pass to the database connection. See</span>
<span class="c1">#  sqlalchemy.create_engine for details.</span>
<span class="c1">#c.JupyterHub.db_kwargs = {}</span>

<span class="c1">## url for the database. e.g. `sqlite:///jupyterhub.sqlite`</span>
<span class="c1">#c.JupyterHub.db_url = &#39;sqlite:///jupyterhub.sqlite&#39;</span>

<span class="c1">## log all database transactions. This has A LOT of output</span>
<span class="c1">#c.JupyterHub.debug_db = False</span>

<span class="c1">## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.debug</span>
<span class="c1">#c.JupyterHub.debug_proxy = False</span>

<span class="c1">## If named servers are enabled, default name of server to spawn or open, e.g. by</span>
<span class="c1">#  user-redirect.</span>
<span class="c1">#c.JupyterHub.default_server_name = &#39;&#39;</span>

<span class="c1">## The default URL for users when they arrive (e.g. when user directs to &quot;/&quot;)</span>
<span class="c1">#  </span>
<span class="c1">#  By default, redirects users to their own server.</span>
<span class="c1">#c.JupyterHub.default_url = &#39;&#39;</span>

<span class="c1">## Dict authority:dict(files). Specify the key, cert, and/or ca file for an</span>
<span class="c1">#  authority. This is useful for externally managed proxies that wish to use</span>
<span class="c1">#  internal_ssl.</span>
<span class="c1">#  </span>
<span class="c1">#  The files dict has this format (you must specify at least a cert)::</span>
<span class="c1">#  </span>
<span class="c1">#      {</span>
<span class="c1">#          &#39;key&#39;: &#39;/path/to/key.key&#39;,</span>
<span class="c1">#          &#39;cert&#39;: &#39;/path/to/cert.crt&#39;,</span>
<span class="c1">#          &#39;ca&#39;: &#39;/path/to/ca.crt&#39;</span>
<span class="c1">#      }</span>
<span class="c1">#  </span>
<span class="c1">#  The authorities you can override: &#39;hub-ca&#39;, &#39;notebooks-ca&#39;, &#39;proxy-api-ca&#39;,</span>
<span class="c1">#  &#39;proxy-client-ca&#39;, and &#39;services-ca&#39;.</span>
<span class="c1">#  </span>
<span class="c1">#  Use with internal_ssl</span>
<span class="c1">#c.JupyterHub.external_ssl_authorities = {}</span>

<span class="c1">## Register extra tornado Handlers for jupyterhub.</span>
<span class="c1">#  </span>
<span class="c1">#  Should be of the form ``(&quot;&lt;regex&gt;&quot;, Handler)``</span>
<span class="c1">#  </span>
<span class="c1">#  The Hub prefix will be added, so `/my-page` will be served at `/hub/my-page`.</span>
<span class="c1">#c.JupyterHub.extra_handlers = []</span>

<span class="c1">## DEPRECATED: use output redirection instead, e.g.</span>
<span class="c1">#  </span>
<span class="c1">#  jupyterhub &amp;&gt;&gt; /var/log/jupyterhub.log</span>
<span class="c1">#c.JupyterHub.extra_log_file = &#39;&#39;</span>

<span class="c1">## Extra log handlers to set on JupyterHub logger</span>
<span class="c1">#c.JupyterHub.extra_log_handlers = []</span>

<span class="c1">## Generate certs used for internal ssl</span>
<span class="c1">#c.JupyterHub.generate_certs = False</span>

<span class="c1">## Generate default config file</span>
<span class="c1">#c.JupyterHub.generate_config = False</span>

<span class="c1">## The URL on which the Hub will listen. This is a private URL for internal</span>
<span class="c1">#  communication. Typically set in combination with hub_connect_url. If a unix</span>
<span class="c1">#  socket, hub_connect_url **must** also be set.</span>
<span class="c1">#  </span>
<span class="c1">#  For example:</span>
<span class="c1">#  </span>
<span class="c1">#      &quot;http://127.0.0.1:8081&quot;</span>
<span class="c1">#      &quot;unix+http://%2Fsrv%2Fjupyterhub%2Fjupyterhub.sock&quot;</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded:: 0.9</span>
<span class="c1">#c.JupyterHub.hub_bind_url = &#39;&#39;</span>

<span class="c1">## The ip or hostname for proxies and spawners to use for connecting to the Hub.</span>
<span class="c1">#  </span>
<span class="c1">#  Use when the bind address (`hub_ip`) is 0.0.0.0, :: or otherwise different</span>
<span class="c1">#  from the connect address.</span>
<span class="c1">#  </span>
<span class="c1">#  Default: when `hub_ip` is 0.0.0.0 or ::, use `socket.gethostname()`, otherwise</span>
<span class="c1">#  use `hub_ip`.</span>
<span class="c1">#  </span>
<span class="c1">#  Note: Some spawners or proxy implementations might not support hostnames.</span>
<span class="c1">#  Check your spawner or proxy documentation to see if they have extra</span>
<span class="c1">#  requirements.</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded:: 0.8</span>
<span class="c1">#c.JupyterHub.hub_connect_ip = &#39;&#39;</span>

<span class="c1">## DEPRECATED</span>
<span class="c1">#  </span>
<span class="c1">#  Use hub_connect_url</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded:: 0.8</span>
<span class="c1">#  </span>
<span class="c1">#  .. deprecated:: 0.9</span>
<span class="c1">#      Use hub_connect_url</span>
<span class="c1">#c.JupyterHub.hub_connect_port = 0</span>

<span class="c1">## The URL for connecting to the Hub. Spawners, services, and the proxy will use</span>
<span class="c1">#  this URL to talk to the Hub.</span>
<span class="c1">#  </span>
<span class="c1">#  Only needs to be specified if the default hub URL is not connectable (e.g.</span>
<span class="c1">#  using a unix+http:// bind url).</span>
<span class="c1">#  </span>
<span class="c1">#  .. seealso::</span>
<span class="c1">#      JupyterHub.hub_connect_ip</span>
<span class="c1">#      JupyterHub.hub_bind_url</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded:: 0.9</span>
<span class="c1">#c.JupyterHub.hub_connect_url = &#39;&#39;</span>

<span class="c1">## The ip address for the Hub process to *bind* to.</span>
<span class="c1">#  </span>
<span class="c1">#  By default, the hub listens on localhost only. This address must be accessible</span>
<span class="c1">#  from the proxy and user servers. You may need to set this to a public ip or &#39;&#39;</span>
<span class="c1">#  for all interfaces if the proxy or user servers are in containers or on a</span>
<span class="c1">#  different host.</span>
<span class="c1">#  </span>
<span class="c1">#  See `hub_connect_ip` for cases where the bind and connect address should</span>
<span class="c1">#  differ, or `hub_bind_url` for setting the full bind URL.</span>
<span class="c1">#c.JupyterHub.hub_ip = &#39;127.0.0.1&#39;</span>

<span class="c1">## The internal port for the Hub process.</span>
<span class="c1">#  </span>
<span class="c1">#  This is the internal port of the hub itself. It should never be accessed</span>
<span class="c1">#  directly. See JupyterHub.port for the public port to use when accessing</span>
<span class="c1">#  jupyterhub. It is rare that this port should be set except in cases of port</span>
<span class="c1">#  conflict.</span>
<span class="c1">#  </span>
<span class="c1">#  See also `hub_ip` for the ip and `hub_bind_url` for setting the full bind URL.</span>
<span class="c1">#c.JupyterHub.hub_port = 8081</span>

<span class="c1">## Trigger implicit spawns after this many seconds.</span>
<span class="c1">#  </span>
<span class="c1">#  When a user visits a URL for a server that&#39;s not running, they are shown a</span>
<span class="c1">#  page indicating that the requested server is not running with a button to</span>
<span class="c1">#  spawn the server.</span>
<span class="c1">#  </span>
<span class="c1">#  Setting this to a positive value will redirect the user after this many</span>
<span class="c1">#  seconds, effectively clicking this button automatically for the users,</span>
<span class="c1">#  automatically beginning the spawn process.</span>
<span class="c1">#  </span>
<span class="c1">#  Warning: this can result in errors and surprising behavior when sharing access</span>
<span class="c1">#  URLs to actual servers, since the wrong server is likely to be started.</span>
<span class="c1">#c.JupyterHub.implicit_spawn_seconds = 0</span>

<span class="c1">## Timeout (in seconds) to wait for spawners to initialize</span>
<span class="c1">#  </span>
<span class="c1">#  Checking if spawners are healthy can take a long time if many spawners are</span>
<span class="c1">#  active at hub start time.</span>
<span class="c1">#  </span>
<span class="c1">#  If it takes longer than this timeout to check, init_spawner will be left to</span>
<span class="c1">#  complete in the background and the http server is allowed to start.</span>
<span class="c1">#  </span>
<span class="c1">#  A timeout of -1 means wait forever, which can mean a slow startup of the Hub</span>
<span class="c1">#  but ensures that the Hub is fully consistent by the time it starts responding</span>
<span class="c1">#  to requests. This matches the behavior of jupyterhub 1.0.</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded: 1.1.0</span>
<span class="c1">#c.JupyterHub.init_spawners_timeout = 10</span>

<span class="c1">## The location to store certificates automatically created by JupyterHub.</span>
<span class="c1">#  </span>
<span class="c1">#  Use with internal_ssl</span>
<span class="c1">#c.JupyterHub.internal_certs_location = &#39;internal-ssl&#39;</span>

<span class="c1">## Enable SSL for all internal communication</span>
<span class="c1">#  </span>
<span class="c1">#  This enables end-to-end encryption between all JupyterHub components.</span>
<span class="c1">#  JupyterHub will automatically create the necessary certificate authority and</span>
<span class="c1">#  sign notebook certificates as they&#39;re created.</span>
<span class="c1">#c.JupyterHub.internal_ssl = False</span>

<span class="c1">## The public facing ip of the whole JupyterHub application (specifically</span>
<span class="c1">#  referred to as the proxy).</span>
<span class="c1">#  </span>
<span class="c1">#  This is the address on which the proxy will listen. The default is to listen</span>
<span class="c1">#  on all interfaces. This is the only address through which JupyterHub should be</span>
<span class="c1">#  accessed by users.</span>
<span class="c1">#  </span>
<span class="c1">#  .. deprecated: 0.9</span>
<span class="c1">#      Use JupyterHub.bind_url</span>
<span class="c1">#c.JupyterHub.ip = &#39;&#39;</span>

<span class="c1">## Supply extra arguments that will be passed to Jinja environment.</span>
<span class="c1">#c.JupyterHub.jinja_environment_options = {}</span>

<span class="c1">## Interval (in seconds) at which to update last-activity timestamps.</span>
<span class="c1">#c.JupyterHub.last_activity_interval = 300</span>

<span class="c1">## Dict of &#39;group&#39;: [&#39;usernames&#39;] to load at startup.</span>
<span class="c1">#  </span>
<span class="c1">#  This strictly *adds* groups and users to groups.</span>
<span class="c1">#  </span>
<span class="c1">#  Loading one set of groups, then starting JupyterHub again with a different set</span>
<span class="c1">#  will not remove users or groups from previous launches. That must be done</span>
<span class="c1">#  through the API.</span>
<span class="c1">#c.JupyterHub.load_groups = {}</span>

<span class="c1">## Specify path to a logo image to override the Jupyter logo in the banner.</span>
<span class="c1">#c.JupyterHub.logo_file = &#39;&#39;</span>

<span class="c1">## Maximum number of concurrent named servers that can be created by a user at a</span>
<span class="c1">#  time.</span>
<span class="c1">#  </span>
<span class="c1">#  Setting this can limit the total resources a user can consume.</span>
<span class="c1">#  </span>
<span class="c1">#  If set to 0, no limit is enforced.</span>
<span class="c1">#c.JupyterHub.named_server_limit_per_user = 0</span>

<span class="c1">## File to write PID Useful for daemonizing JupyterHub.</span>
<span class="c1">#c.JupyterHub.pid_file = &#39;&#39;</span>

<span class="c1">## The public facing port of the proxy.</span>
<span class="c1">#  </span>
<span class="c1">#  This is the port on which the proxy will listen. This is the only port through</span>
<span class="c1">#  which JupyterHub should be accessed by users.</span>
<span class="c1">#  </span>
<span class="c1">#  .. deprecated: 0.9</span>
<span class="c1">#      Use JupyterHub.bind_url</span>
<span class="c1">#c.JupyterHub.port = 8000</span>

<span class="c1">## DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url</span>
<span class="c1">#c.JupyterHub.proxy_api_ip = &#39;&#39;</span>

<span class="c1">## DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url</span>
<span class="c1">#c.JupyterHub.proxy_api_port = 0</span>

<span class="c1">## DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.auth_token</span>
<span class="c1">#c.JupyterHub.proxy_auth_token = &#39;&#39;</span>

<span class="c1">## Interval (in seconds) at which to check if the proxy is running.</span>
<span class="c1">#c.JupyterHub.proxy_check_interval = 30</span>

<span class="c1">## The class to use for configuring the JupyterHub proxy.</span>
<span class="c1">#  </span>
<span class="c1">#          Should be a subclass of :class:`jupyterhub.proxy.Proxy`.</span>
<span class="c1">#  </span>
<span class="c1">#          .. versionchanged:: 1.0</span>
<span class="c1">#              proxies may be registered via entry points,</span>
<span class="c1">#              e.g. `c.JupyterHub.proxy_class = &#39;traefik&#39;`</span>
<span class="c1">#  </span>
<span class="c1">#  Currently installed: </span>
<span class="c1">#    - configurable-http-proxy: jupyterhub.proxy.ConfigurableHTTPProxy</span>
<span class="c1">#    - default: jupyterhub.proxy.ConfigurableHTTPProxy</span>
<span class="c1">#c.JupyterHub.proxy_class = &#39;jupyterhub.proxy.ConfigurableHTTPProxy&#39;</span>

<span class="c1">## DEPRECATED since version 0.8. Use ConfigurableHTTPProxy.command</span>
<span class="c1">#c.JupyterHub.proxy_cmd = []</span>

<span class="c1">## Recreate all certificates used within JupyterHub on restart.</span>
<span class="c1">#  </span>
<span class="c1">#  Note: enabling this feature requires restarting all notebook servers.</span>
<span class="c1">#  </span>
<span class="c1">#  Use with internal_ssl</span>
<span class="c1">#c.JupyterHub.recreate_internal_certs = False</span>

<span class="c1">## Redirect user to server (if running), instead of control panel.</span>
<span class="c1">#c.JupyterHub.redirect_to_server = True</span>

<span class="c1">## Purge and reset the database.</span>
<span class="c1">#c.JupyterHub.reset_db = False</span>

<span class="c1">## Interval (in seconds) at which to check connectivity of services with web</span>
<span class="c1">#  endpoints.</span>
<span class="c1">#c.JupyterHub.service_check_interval = 60</span>

<span class="c1">## Dict of token:servicename to be loaded into the database.</span>
<span class="c1">#  </span>
<span class="c1">#  Allows ahead-of-time generation of API tokens for use by externally managed</span>
<span class="c1">#  services.</span>
<span class="c1">#c.JupyterHub.service_tokens = {}</span>

<span class="c1">## List of service specification dictionaries.</span>
<span class="c1">#  </span>
<span class="c1">#  A service</span>
<span class="c1">#  </span>
<span class="c1">#  For instance::</span>
<span class="c1">#  </span>
<span class="c1">#      services = [</span>
<span class="c1">#          {</span>
<span class="c1">#              &#39;name&#39;: &#39;cull_idle&#39;,</span>
<span class="c1">#              &#39;command&#39;: [&#39;/path/to/cull_idle_servers.py&#39;],</span>
<span class="c1">#          },</span>
<span class="c1">#          {</span>
<span class="c1">#              &#39;name&#39;: &#39;formgrader&#39;,</span>
<span class="c1">#              &#39;url&#39;: &#39;http://127.0.0.1:1234&#39;,</span>
<span class="c1">#              &#39;api_token&#39;: &#39;super-secret&#39;,</span>
<span class="c1">#              &#39;environment&#39;:</span>
<span class="c1">#          }</span>
<span class="c1">#      ]</span>
<span class="c1">#c.JupyterHub.services = []</span>

<span class="c1">## Shuts down all user servers on logout</span>
<span class="c1">#c.JupyterHub.shutdown_on_logout = False</span>

<span class="c1">## The class to use for spawning single-user servers.</span>
<span class="c1">#  </span>
<span class="c1">#          Should be a subclass of :class:`jupyterhub.spawner.Spawner`.</span>
<span class="c1">#  </span>
<span class="c1">#          .. versionchanged:: 1.0</span>
<span class="c1">#              spawners may be registered via entry points,</span>
<span class="c1">#              e.g. `c.JupyterHub.spawner_class = &#39;localprocess&#39;`</span>
<span class="c1">#  </span>
<span class="c1">#  Currently installed: </span>
<span class="c1">#    - default: jupyterhub.spawner.LocalProcessSpawner</span>
<span class="c1">#    - localprocess: jupyterhub.spawner.LocalProcessSpawner</span>
<span class="c1">#    - simple: jupyterhub.spawner.SimpleLocalProcessSpawner</span>
<span class="c1">#c.JupyterHub.spawner_class = &#39;jupyterhub.spawner.LocalProcessSpawner&#39;</span>

<span class="c1">## Path to SSL certificate file for the public facing interface of the proxy</span>
<span class="c1">#  </span>
<span class="c1">#  When setting this, you should also set ssl_key</span>
<span class="c1">#c.JupyterHub.ssl_cert = &#39;&#39;</span>

<span class="c1">## Path to SSL key file for the public facing interface of the proxy</span>
<span class="c1">#  </span>
<span class="c1">#  When setting this, you should also set ssl_cert</span>
<span class="c1">#c.JupyterHub.ssl_key = &#39;&#39;</span>

<span class="c1">## Host to send statsd metrics to. An empty string (the default) disables sending</span>
<span class="c1">#  metrics.</span>
<span class="c1">#c.JupyterHub.statsd_host = &#39;&#39;</span>

<span class="c1">## Port on which to send statsd metrics about the hub</span>
<span class="c1">#c.JupyterHub.statsd_port = 8125</span>

<span class="c1">## Prefix to use for all metrics sent by jupyterhub to statsd</span>
<span class="c1">#c.JupyterHub.statsd_prefix = &#39;jupyterhub&#39;</span>

<span class="c1">## Run single-user servers on subdomains of this host.</span>
<span class="c1">#  </span>
<span class="c1">#  This should be the full `https://hub.domain.tld[:port]`.</span>
<span class="c1">#  </span>
<span class="c1">#  Provides additional cross-site protections for javascript served by single-</span>
<span class="c1">#  user servers.</span>
<span class="c1">#  </span>
<span class="c1">#  Requires `&lt;username&gt;.hub.domain.tld` to resolve to the same host as</span>
<span class="c1">#  `hub.domain.tld`.</span>
<span class="c1">#  </span>
<span class="c1">#  In general, this is most easily achieved with wildcard DNS.</span>
<span class="c1">#  </span>
<span class="c1">#  When using SSL (i.e. always) this also requires a wildcard SSL certificate.</span>
<span class="c1">#c.JupyterHub.subdomain_host = &#39;&#39;</span>

<span class="c1">## Paths to search for jinja templates, before using the default templates.</span>
<span class="c1">#c.JupyterHub.template_paths = []</span>

<span class="c1">## Extra variables to be passed into jinja templates</span>
<span class="c1">#c.JupyterHub.template_vars = {}</span>

<span class="c1">## Extra settings overrides to pass to the tornado application.</span>
<span class="c1">#c.JupyterHub.tornado_settings = {}</span>

<span class="c1">## Trust user-provided tokens (via JupyterHub.service_tokens) to have good</span>
<span class="c1">#  entropy.</span>
<span class="c1">#  </span>
<span class="c1">#  If you are not inserting additional tokens via configuration file, this flag</span>
<span class="c1">#  has no effect.</span>
<span class="c1">#  </span>
<span class="c1">#  In JupyterHub 0.8, internally generated tokens do not pass through additional</span>
<span class="c1">#  hashing because the hashing is costly and does not increase the entropy of</span>
<span class="c1">#  already-good UUIDs.</span>
<span class="c1">#  </span>
<span class="c1">#  User-provided tokens, on the other hand, are not trusted to have good entropy</span>
<span class="c1">#  by default, and are passed through many rounds of hashing to stretch the</span>
<span class="c1">#  entropy of the key (i.e. user-provided tokens are treated as passwords instead</span>
<span class="c1">#  of random keys). These keys are more costly to check.</span>
<span class="c1">#  </span>
<span class="c1">#  If your inserted tokens are generated by a good-quality mechanism, e.g.</span>
<span class="c1">#  `openssl rand -hex 32`, then you can set this flag to True to reduce the cost</span>
<span class="c1">#  of checking authentication tokens.</span>
<span class="c1">#c.JupyterHub.trust_user_provided_tokens = False</span>

<span class="c1">## Names to include in the subject alternative name.</span>
<span class="c1">#  </span>
<span class="c1">#  These names will be used for server name verification. This is useful if</span>
<span class="c1">#  JupyterHub is being run behind a reverse proxy or services using ssl are on</span>
<span class="c1">#  different hosts.</span>
<span class="c1">#  </span>
<span class="c1">#  Use with internal_ssl</span>
<span class="c1">#c.JupyterHub.trusted_alt_names = []</span>

<span class="c1">## Downstream proxy IP addresses to trust.</span>
<span class="c1">#  </span>
<span class="c1">#  This sets the list of IP addresses that are trusted and skipped when</span>
<span class="c1">#  processing the `X-Forwarded-For` header. For example, if an external proxy is</span>
<span class="c1">#  used for TLS termination, its IP address should be added to this list to</span>
<span class="c1">#  ensure the correct client IP addresses are recorded in the logs instead of the</span>
<span class="c1">#  proxy server&#39;s IP address.</span>
<span class="c1">#c.JupyterHub.trusted_downstream_ips = []</span>

<span class="c1">## Upgrade the database automatically on start.</span>
<span class="c1">#  </span>
<span class="c1">#  Only safe if database is regularly backed up. Only SQLite databases will be</span>
<span class="c1">#  backed up to a local file automatically.</span>
<span class="c1">#c.JupyterHub.upgrade_db = False</span>

<span class="c1">## Callable to affect behavior of /user-redirect/</span>
<span class="c1">#  </span>
<span class="c1">#  Receives 4 parameters: 1. path - URL path that was provided after /user-</span>
<span class="c1">#  redirect/ 2. request - A Tornado HTTPServerRequest representing the current</span>
<span class="c1">#  request. 3. user - The currently authenticated user. 4. base_url - The</span>
<span class="c1">#  base_url of the current hub, for relative redirects</span>
<span class="c1">#  </span>
<span class="c1">#  It should return the new URL to redirect to, or None to preserve current</span>
<span class="c1">#  behavior.</span>
<span class="c1">#c.JupyterHub.user_redirect_hook = None</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Spawner(LoggingConfigurable) configuration</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="c1">## Base class for spawning single-user notebook servers.</span>
<span class="c1">#  </span>
<span class="c1">#  Subclass this, and override the following methods:</span>
<span class="c1">#  </span>
<span class="c1">#  - load_state - get_state - start - stop - poll</span>
<span class="c1">#  </span>
<span class="c1">#  As JupyterHub supports multiple users, an instance of the Spawner subclass is</span>
<span class="c1">#  created for each user. If there are 20 JupyterHub users, there will be 20</span>
<span class="c1">#  instances of the subclass.</span>

<span class="c1">## Extra arguments to be passed to the single-user server.</span>
<span class="c1">#  </span>
<span class="c1">#  Some spawners allow shell-style expansion here, allowing you to use</span>
<span class="c1">#  environment variables here. Most, including the default, do not. Consult the</span>
<span class="c1">#  documentation for your spawner to verify!</span>
<span class="c1">#c.Spawner.args = []</span>

<span class="c1">## An optional hook function that you can implement to pass `auth_state` to the</span>
<span class="c1">#  spawner after it has been initialized but before it starts. The `auth_state`</span>
<span class="c1">#  dictionary may be set by the `.authenticate()` method of the authenticator.</span>
<span class="c1">#  This hook enables you to pass some or all of that information to your spawner.</span>
<span class="c1">#  </span>
<span class="c1">#  Example::</span>
<span class="c1">#  </span>
<span class="c1">#      def userdata_hook(spawner, auth_state):</span>
<span class="c1">#          spawner.userdata = auth_state[&quot;userdata&quot;]</span>
<span class="c1">#  </span>
<span class="c1">#      c.Spawner.auth_state_hook = userdata_hook</span>
<span class="c1">#c.Spawner.auth_state_hook = None</span>

<span class="c1">## The command used for starting the single-user server.</span>
<span class="c1">#  </span>
<span class="c1">#  Provide either a string or a list containing the path to the startup script</span>
<span class="c1">#  command. Extra arguments, other than this path, should be provided via `args`.</span>
<span class="c1">#  </span>
<span class="c1">#  This is usually set if you want to start the single-user server in a different</span>
<span class="c1">#  python environment (with virtualenv/conda) than JupyterHub itself.</span>
<span class="c1">#  </span>
<span class="c1">#  Some spawners allow shell-style expansion here, allowing you to use</span>
<span class="c1">#  environment variables. Most, including the default, do not. Consult the</span>
<span class="c1">#  documentation for your spawner to verify!</span>
<span class="c1">#c.Spawner.cmd = [&#39;jupyterhub-singleuser&#39;]</span>

<span class="c1">## Maximum number of consecutive failures to allow before shutting down</span>
<span class="c1">#  JupyterHub.</span>
<span class="c1">#  </span>
<span class="c1">#  This helps JupyterHub recover from a certain class of problem preventing</span>
<span class="c1">#  launch in contexts where the Hub is automatically restarted (e.g. systemd,</span>
<span class="c1">#  docker, kubernetes).</span>
<span class="c1">#  </span>
<span class="c1">#  A limit of 0 means no limit and consecutive failures will not be tracked.</span>
<span class="c1">#c.Spawner.consecutive_failure_limit = 0</span>

<span class="c1">## Minimum number of cpu-cores a single-user notebook server is guaranteed to</span>
<span class="c1">#  have available.</span>
<span class="c1">#  </span>
<span class="c1">#  If this value is set to 0.5, allows use of 50% of one CPU. If this value is</span>
<span class="c1">#  set to 2, allows use of up to 2 CPUs.</span>
<span class="c1">#  </span>
<span class="c1">#  **This is a configuration setting. Your spawner must implement support for the</span>
<span class="c1">#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**</span>
<span class="c1">#  implement this support. A custom spawner **must** add support for this setting</span>
<span class="c1">#  for it to be enforced.</span>
<span class="c1">#c.Spawner.cpu_guarantee = None</span>

<span class="c1">## Maximum number of cpu-cores a single-user notebook server is allowed to use.</span>
<span class="c1">#  </span>
<span class="c1">#  If this value is set to 0.5, allows use of 50% of one CPU. If this value is</span>
<span class="c1">#  set to 2, allows use of up to 2 CPUs.</span>
<span class="c1">#  </span>
<span class="c1">#  The single-user notebook server will never be scheduled by the kernel to use</span>
<span class="c1">#  more cpu-cores than this. There is no guarantee that it can access this many</span>
<span class="c1">#  cpu-cores.</span>
<span class="c1">#  </span>
<span class="c1">#  **This is a configuration setting. Your spawner must implement support for the</span>
<span class="c1">#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**</span>
<span class="c1">#  implement this support. A custom spawner **must** add support for this setting</span>
<span class="c1">#  for it to be enforced.</span>
<span class="c1">#c.Spawner.cpu_limit = None</span>

<span class="c1">## Enable debug-logging of the single-user server</span>
<span class="c1">#c.Spawner.debug = False</span>

<span class="c1">## The URL the single-user server should start in.</span>
<span class="c1">#  </span>
<span class="c1">#  `{username}` will be expanded to the user&#39;s username</span>
<span class="c1">#  </span>
<span class="c1">#  Example uses:</span>
<span class="c1">#  </span>
<span class="c1">#  - You can set `notebook_dir` to `/` and `default_url` to `/tree/home/{username}` to allow people to</span>
<span class="c1">#    navigate the whole filesystem from their notebook server, but still start in their home directory.</span>
<span class="c1">#  - Start with `/notebooks` instead of `/tree` if `default_url` points to a notebook instead of a directory.</span>
<span class="c1">#  - You can set this to `/lab` to have JupyterLab start by default, rather than Jupyter Notebook.</span>
<span class="c1">#c.Spawner.default_url = &#39;&#39;</span>

<span class="c1">## Disable per-user configuration of single-user servers.</span>
<span class="c1">#  </span>
<span class="c1">#  When starting the user&#39;s single-user server, any config file found in the</span>
<span class="c1">#  user&#39;s $HOME directory will be ignored.</span>
<span class="c1">#  </span>
<span class="c1">#  Note: a user could circumvent this if the user modifies their Python</span>
<span class="c1">#  environment, such as when they have their own conda environments / virtualenvs</span>
<span class="c1">#  / containers.</span>
<span class="c1">#c.Spawner.disable_user_config = False</span>

<span class="c1">## Whitelist of environment variables for the single-user server to inherit from</span>
<span class="c1">#  the JupyterHub process.</span>
<span class="c1">#  </span>
<span class="c1">#  This whitelist is used to ensure that sensitive information in the JupyterHub</span>
<span class="c1">#  process&#39;s environment (such as `CONFIGPROXY_AUTH_TOKEN`) is not passed to the</span>
<span class="c1">#  single-user server&#39;s process.</span>
<span class="c1">#c.Spawner.env_keep = [&#39;PATH&#39;, &#39;PYTHONPATH&#39;, &#39;CONDA_ROOT&#39;, &#39;CONDA_DEFAULT_ENV&#39;, &#39;VIRTUAL_ENV&#39;, &#39;LANG&#39;, &#39;LC_ALL&#39;]</span>

<span class="c1">## Extra environment variables to set for the single-user server&#39;s process.</span>
<span class="c1">#  </span>
<span class="c1">#  Environment variables that end up in the single-user server&#39;s process come from 3 sources:</span>
<span class="c1">#    - This `environment` configurable</span>
<span class="c1">#    - The JupyterHub process&#39; environment variables that are whitelisted in `env_keep`</span>
<span class="c1">#    - Variables to establish contact between the single-user notebook and the hub (such as JUPYTERHUB_API_TOKEN)</span>
<span class="c1">#  </span>
<span class="c1">#  The `environment` configurable should be set by JupyterHub administrators to</span>
<span class="c1">#  add installation specific environment variables. It is a dict where the key is</span>
<span class="c1">#  the name of the environment variable, and the value can be a string or a</span>
<span class="c1">#  callable. If it is a callable, it will be called with one parameter (the</span>
<span class="c1">#  spawner instance), and should return a string fairly quickly (no blocking</span>
<span class="c1">#  operations please!).</span>
<span class="c1">#  </span>
<span class="c1">#  Note that the spawner class&#39; interface is not guaranteed to be exactly same</span>
<span class="c1">#  across upgrades, so if you are using the callable take care to verify it</span>
<span class="c1">#  continues to work after upgrades!</span>
<span class="c1">#c.Spawner.environment = {}</span>

<span class="c1">## Timeout (in seconds) before giving up on a spawned HTTP server</span>
<span class="c1">#  </span>
<span class="c1">#  Once a server has successfully been spawned, this is the amount of time we</span>
<span class="c1">#  wait before assuming that the server is unable to accept connections.</span>
<span class="c1">#c.Spawner.http_timeout = 30</span>

<span class="c1">## The IP address (or hostname) the single-user server should listen on.</span>
<span class="c1">#  </span>
<span class="c1">#  The JupyterHub proxy implementation should be able to send packets to this</span>
<span class="c1">#  interface.</span>
<span class="c1">#c.Spawner.ip = &#39;&#39;</span>

<span class="c1">## Minimum number of bytes a single-user notebook server is guaranteed to have</span>
<span class="c1">#  available.</span>
<span class="c1">#  </span>
<span class="c1">#  Allows the following suffixes:</span>
<span class="c1">#    - K -&gt; Kilobytes</span>
<span class="c1">#    - M -&gt; Megabytes</span>
<span class="c1">#    - G -&gt; Gigabytes</span>
<span class="c1">#    - T -&gt; Terabytes</span>
<span class="c1">#  </span>
<span class="c1">#  **This is a configuration setting. Your spawner must implement support for the</span>
<span class="c1">#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**</span>
<span class="c1">#  implement this support. A custom spawner **must** add support for this setting</span>
<span class="c1">#  for it to be enforced.</span>
<span class="c1">#c.Spawner.mem_guarantee = None</span>

<span class="c1">## Maximum number of bytes a single-user notebook server is allowed to use.</span>
<span class="c1">#  </span>
<span class="c1">#  Allows the following suffixes:</span>
<span class="c1">#    - K -&gt; Kilobytes</span>
<span class="c1">#    - M -&gt; Megabytes</span>
<span class="c1">#    - G -&gt; Gigabytes</span>
<span class="c1">#    - T -&gt; Terabytes</span>
<span class="c1">#  </span>
<span class="c1">#  If the single user server tries to allocate more memory than this, it will</span>
<span class="c1">#  fail. There is no guarantee that the single-user notebook server will be able</span>
<span class="c1">#  to allocate this much memory - only that it can not allocate more than this.</span>
<span class="c1">#  </span>
<span class="c1">#  **This is a configuration setting. Your spawner must implement support for the</span>
<span class="c1">#  limit to work.** The default spawner, `LocalProcessSpawner`, does **not**</span>
<span class="c1">#  implement this support. A custom spawner **must** add support for this setting</span>
<span class="c1">#  for it to be enforced.</span>
<span class="c1">#c.Spawner.mem_limit = None</span>

<span class="c1">## Path to the notebook directory for the single-user server.</span>
<span class="c1">#  </span>
<span class="c1">#  The user sees a file listing of this directory when the notebook interface is</span>
<span class="c1">#  started. The current interface does not easily allow browsing beyond the</span>
<span class="c1">#  subdirectories in this directory&#39;s tree.</span>
<span class="c1">#  </span>
<span class="c1">#  `~` will be expanded to the home directory of the user, and {username} will be</span>
<span class="c1">#  replaced with the name of the user.</span>
<span class="c1">#  </span>
<span class="c1">#  Note that this does *not* prevent users from accessing files outside of this</span>
<span class="c1">#  path! They can do so with many other means.</span>
<span class="c1">#c.Spawner.notebook_dir = &#39;&#39;</span>

<span class="c1">## An HTML form for options a user can specify on launching their server.</span>
<span class="c1">#  </span>
<span class="c1">#  The surrounding `&lt;form&gt;` element and the submit button are already provided.</span>
<span class="c1">#  </span>
<span class="c1">#  For example:</span>
<span class="c1">#  </span>
<span class="c1">#  .. code:: html</span>
<span class="c1">#  </span>
<span class="c1">#      Set your key:</span>
<span class="c1">#      &lt;input name=&quot;key&quot; val=&quot;default_key&quot;&gt;&lt;/input&gt;</span>
<span class="c1">#      &lt;br&gt;</span>
<span class="c1">#      Choose a letter:</span>
<span class="c1">#      &lt;select name=&quot;letter&quot; multiple=&quot;true&quot;&gt;</span>
<span class="c1">#        &lt;option value=&quot;A&quot;&gt;The letter A&lt;/option&gt;</span>
<span class="c1">#        &lt;option value=&quot;B&quot;&gt;The letter B&lt;/option&gt;</span>
<span class="c1">#      &lt;/select&gt;</span>
<span class="c1">#  </span>
<span class="c1">#  The data from this form submission will be passed on to your spawner in</span>
<span class="c1">#  `self.user_options`</span>
<span class="c1">#  </span>
<span class="c1">#  Instead of a form snippet string, this could also be a callable that takes as</span>
<span class="c1">#  one parameter the current spawner instance and returns a string. The callable</span>
<span class="c1">#  will be called asynchronously if it returns a future, rather than a str. Note</span>
<span class="c1">#  that the interface of the spawner class is not deemed stable across versions,</span>
<span class="c1">#  so using this functionality might cause your JupyterHub upgrades to break.</span>
<span class="c1">#c.Spawner.options_form = traitlets.Undefined</span>

<span class="c1">## Interval (in seconds) on which to poll the spawner for single-user server&#39;s</span>
<span class="c1">#  status.</span>
<span class="c1">#  </span>
<span class="c1">#  At every poll interval, each spawner&#39;s `.poll` method is called, which checks</span>
<span class="c1">#  if the single-user server is still running. If it isn&#39;t running, then</span>
<span class="c1">#  JupyterHub modifies its own state accordingly and removes appropriate routes</span>
<span class="c1">#  from the configurable proxy.</span>
<span class="c1">#c.Spawner.poll_interval = 30</span>

<span class="c1">## The port for single-user servers to listen on.</span>
<span class="c1">#  </span>
<span class="c1">#  Defaults to `0`, which uses a randomly allocated port number each time.</span>
<span class="c1">#  </span>
<span class="c1">#  If set to a non-zero value, all Spawners will use the same port, which only</span>
<span class="c1">#  makes sense if each server is on a different address, e.g. in containers.</span>
<span class="c1">#  </span>
<span class="c1">#  New in version 0.7.</span>
<span class="c1">#c.Spawner.port = 0</span>

<span class="c1">## An optional hook function that you can implement to do work after the spawner</span>
<span class="c1">#  stops.</span>
<span class="c1">#  </span>
<span class="c1">#  This can be set independent of any concrete spawner implementation.</span>
<span class="c1">#c.Spawner.post_stop_hook = None</span>

<span class="c1">## An optional hook function that you can implement to do some bootstrapping work</span>
<span class="c1">#  before the spawner starts. For example, create a directory for your user or</span>
<span class="c1">#  load initial content.</span>
<span class="c1">#  </span>
<span class="c1">#  This can be set independent of any concrete spawner implementation.</span>
<span class="c1">#  </span>
<span class="c1">#  This maybe a coroutine.</span>
<span class="c1">#  </span>
<span class="c1">#  Example::</span>
<span class="c1">#  </span>
<span class="c1">#      from subprocess import check_call</span>
<span class="c1">#      def my_hook(spawner):</span>
<span class="c1">#          username = spawner.user.name</span>
<span class="c1">#          check_call([&#39;./examples/bootstrap-script/bootstrap.sh&#39;, username])</span>
<span class="c1">#  </span>
<span class="c1">#      c.Spawner.pre_spawn_hook = my_hook</span>
<span class="c1">#c.Spawner.pre_spawn_hook = None</span>

<span class="c1">## List of SSL alt names</span>
<span class="c1">#  </span>
<span class="c1">#  May be set in config if all spawners should have the same value(s), or set at</span>
<span class="c1">#  runtime by Spawner that know their names.</span>
<span class="c1">#c.Spawner.ssl_alt_names = []</span>

<span class="c1">## Whether to include DNS:localhost, IP:127.0.0.1 in alt names</span>
<span class="c1">#c.Spawner.ssl_alt_names_include_local = True</span>

<span class="c1">## Timeout (in seconds) before giving up on starting of single-user server.</span>
<span class="c1">#  </span>
<span class="c1">#  This is the timeout for start to return, not the timeout for the server to</span>
<span class="c1">#  respond. Callers of spawner.start will assume that startup has failed if it</span>
<span class="c1">#  takes longer than this. start should return when the server process is started</span>
<span class="c1">#  and its location is known.</span>
<span class="c1">#c.Spawner.start_timeout = 60</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># Authenticator(LoggingConfigurable) configuration</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="c1">## Base class for implementing an authentication provider for JupyterHub</span>

<span class="c1">## Set of users that will have admin rights on this JupyterHub.</span>
<span class="c1">#  </span>
<span class="c1">#  Admin users have extra privileges:</span>
<span class="c1">#   - Use the admin panel to see list of users logged in</span>
<span class="c1">#   - Add / remove users in some authenticators</span>
<span class="c1">#   - Restart / halt the hub</span>
<span class="c1">#   - Start / stop users&#39; single-user servers</span>
<span class="c1">#   - Can access each individual users&#39; single-user server (if configured)</span>
<span class="c1">#  </span>
<span class="c1">#  Admin access should be treated the same way root access is.</span>
<span class="c1">#  </span>
<span class="c1">#  Defaults to an empty set, in which case no user has admin access.</span>
<span class="c1">#c.Authenticator.admin_users = set()</span>

<span class="c1">## The max age (in seconds) of authentication info before forcing a refresh of</span>
<span class="c1">#  user auth info.</span>
<span class="c1">#  </span>
<span class="c1">#  Refreshing auth info allows, e.g. requesting/re-validating auth tokens.</span>
<span class="c1">#  </span>
<span class="c1">#  See :meth:`.refresh_user` for what happens when user auth info is refreshed</span>
<span class="c1">#  (nothing by default).</span>
<span class="c1">#c.Authenticator.auth_refresh_age = 300</span>

<span class="c1">## Automatically begin the login process</span>
<span class="c1">#  </span>
<span class="c1">#  rather than starting with a &quot;Login with...&quot; link at `/hub/login`</span>
<span class="c1">#  </span>
<span class="c1">#  To work, `.login_url()` must give a URL other than the default `/hub/login`,</span>
<span class="c1">#  such as an oauth handler or another automatic login handler, registered with</span>
<span class="c1">#  `.get_handlers()`.</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded:: 0.8</span>
<span class="c1">#c.Authenticator.auto_login = False</span>

<span class="c1">## Blacklist of usernames that are not allowed to log in.</span>
<span class="c1">#  </span>
<span class="c1">#  Use this with supported authenticators to restrict which users can not log in.</span>
<span class="c1">#  This is an additional blacklist that further restricts users, beyond whatever</span>
<span class="c1">#  restrictions the authenticator has in place.</span>
<span class="c1">#  </span>
<span class="c1">#  If empty, does not perform any additional restriction.</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded: 0.9</span>
<span class="c1">#c.Authenticator.blacklist = set()</span>

<span class="c1">## Enable persisting auth_state (if available).</span>
<span class="c1">#  </span>
<span class="c1">#  auth_state will be encrypted and stored in the Hub&#39;s database. This can</span>
<span class="c1">#  include things like authentication tokens, etc. to be passed to Spawners as</span>
<span class="c1">#  environment variables.</span>
<span class="c1">#  </span>
<span class="c1">#  Encrypting auth_state requires the cryptography package.</span>
<span class="c1">#  </span>
<span class="c1">#  Additionally, the JUPYTERHUB_CRYPT_KEY environment variable must contain one</span>
<span class="c1">#  (or more, separated by ;) 32B encryption keys. These can be either base64 or</span>
<span class="c1">#  hex-encoded.</span>
<span class="c1">#  </span>
<span class="c1">#  If encryption is unavailable, auth_state cannot be persisted.</span>
<span class="c1">#  </span>
<span class="c1">#  New in JupyterHub 0.8</span>
<span class="c1">#c.Authenticator.enable_auth_state = False</span>

<span class="c1">## An optional hook function that you can implement to do some bootstrapping work</span>
<span class="c1">#  during authentication. For example, loading user account details from an</span>
<span class="c1">#  external system.</span>
<span class="c1">#  </span>
<span class="c1">#  This function is called after the user has passed all authentication checks</span>
<span class="c1">#  and is ready to successfully authenticate. This function must return the</span>
<span class="c1">#  authentication dict reguardless of changes to it.</span>
<span class="c1">#  </span>
<span class="c1">#  This maybe a coroutine.</span>
<span class="c1">#  </span>
<span class="c1">#  .. versionadded: 1.0</span>
<span class="c1">#  </span>
<span class="c1">#  Example::</span>
<span class="c1">#  </span>
<span class="c1">#      import os, pwd</span>
<span class="c1">#      def my_hook(authenticator, handler, authentication):</span>
<span class="c1">#          user_data = pwd.getpwnam(authentication[&#39;name&#39;])</span>
<span class="c1">#          spawn_data = {</span>
<span class="c1">#              &#39;pw_data&#39;: user_data</span>
<span class="c1">#              &#39;gid_list&#39;: os.getgrouplist(authentication[&#39;name&#39;], user_data.pw_gid)</span>
<span class="c1">#          }</span>
<span class="c1">#  </span>
<span class="c1">#          if authentication[&#39;auth_state&#39;] is None:</span>
<span class="c1">#              authentication[&#39;auth_state&#39;] = {}</span>
<span class="c1">#          authentication[&#39;auth_state&#39;][&#39;spawn_data&#39;] = spawn_data</span>
<span class="c1">#  </span>
<span class="c1">#          return authentication</span>
<span class="c1">#  </span>
<span class="c1">#      c.Authenticator.post_auth_hook = my_hook</span>
<span class="c1">#c.Authenticator.post_auth_hook = None</span>

<span class="c1">## Force refresh of auth prior to spawn.</span>
<span class="c1">#  </span>
<span class="c1">#  This forces :meth:`.refresh_user` to be called prior to launching a server, to</span>
<span class="c1">#  ensure that auth state is up-to-date.</span>
<span class="c1">#  </span>
<span class="c1">#  This can be important when e.g. auth tokens that may have expired are passed</span>
<span class="c1">#  to the spawner via environment variables from auth_state.</span>
<span class="c1">#  </span>
<span class="c1">#  If refresh_user cannot refresh the user auth data, launch will fail until the</span>
<span class="c1">#  user logs in again.</span>
<span class="c1">#c.Authenticator.refresh_pre_spawn = False</span>

<span class="c1">## Dictionary mapping authenticator usernames to JupyterHub users.</span>
<span class="c1">#  </span>
<span class="c1">#  Primarily used to normalize OAuth user names to local users.</span>
<span class="c1">#c.Authenticator.username_map = {}</span>

<span class="c1">## Regular expression pattern that all valid usernames must match.</span>
<span class="c1">#  </span>
<span class="c1">#  If a username does not match the pattern specified here, authentication will</span>
<span class="c1">#  not be attempted.</span>
<span class="c1">#  </span>
<span class="c1">#  If not set, allow any username.</span>
<span class="c1">#c.Authenticator.username_pattern = &#39;&#39;</span>

<span class="c1">## Whitelist of usernames that are allowed to log in.</span>
<span class="c1">#  </span>
<span class="c1">#  Use this with supported authenticators to restrict which users can log in.</span>
<span class="c1">#  This is an additional whitelist that further restricts users, beyond whatever</span>
<span class="c1">#  restrictions the authenticator has in place.</span>
<span class="c1">#  </span>
<span class="c1">#  If empty, does not perform any additional restriction.</span>
<span class="c1">#c.Authenticator.whitelist = set()</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="c1"># CryptKeeper(SingletonConfigurable) configuration</span>
<span class="c1">#------------------------------------------------------------------------------</span>

<span class="c1">## Encapsulate encryption configuration</span>
<span class="c1">#  </span>
<span class="c1">#  Use via the encryption_config singleton below.</span>

<span class="c1">## </span>
<span class="c1">#c.CryptKeeper.keys = []</span>

<span class="c1">## The number of threads to allocate for encryption</span>
<span class="c1">#c.CryptKeeper.n_threads = 8</span>
</pre></div>
</div>
</div>
<div class="section" id="jupyterhub-help-command-output">
<h2>JupyterHub help command output<a class="headerlink" href="#jupyterhub-help-command-output" title="Permalink to this headline">¶</a></h2>
<p>This section contains the output of the command <code class="docutils literal notranslate"><span class="pre">jupyterhub</span> <span class="pre">--help-all</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Start a multi-user Jupyter Notebook server

Spawns a configurable-http-proxy and multi-user Hub, which authenticates users
and spawns single-user Notebook servers on behalf of users.

Subcommands
-----------

Subcommands are launched as `jupyterhub cmd [args]`. For information on using
subcommand &#39;cmd&#39;, do: `jupyterhub cmd -h`.

token
    Generate an API token for a user
upgrade-db
    Upgrade your JupyterHub state database to the current version.

Options
-------

Arguments that take values are actually convenience aliases to full
Configurables, whose aliases are listed on the help line. For more information
on full configurables, see &#39;--help-all&#39;.

--debug
    set log level to logging.DEBUG (maximize logging output)
--generate-config
    generate default config file
--generate-certs
    generate certificates used for internal ssl
--no-db
    disable persisting state database to disk
--upgrade-db
    Automatically upgrade the database if needed on startup.
    
    Only safe if the database has been backed up.
    Only SQLite database files will be backed up automatically.
--no-ssl
    [DEPRECATED in 0.7: does nothing]
--base-url=&lt;URLPrefix&gt; (JupyterHub.base_url)
    Default: &#39;/&#39;
    The base URL of the entire application.
    Add this to the beginning of all JupyterHub URLs. Use base_url to run
    JupyterHub within an existing website.
    .. deprecated: 0.9
        Use JupyterHub.bind_url
-y &lt;Bool&gt; (JupyterHub.answer_yes)
    Default: False
    Answer yes to any questions (e.g. confirm overwrite)
--ssl-key=&lt;Unicode&gt; (JupyterHub.ssl_key)
    Default: &#39;&#39;
    Path to SSL key file for the public facing interface of the proxy
    When setting this, you should also set ssl_cert
--ssl-cert=&lt;Unicode&gt; (JupyterHub.ssl_cert)
    Default: &#39;&#39;
    Path to SSL certificate file for the public facing interface of the proxy
    When setting this, you should also set ssl_key
--url=&lt;Unicode&gt; (JupyterHub.bind_url)
    Default: &#39;http://:8000&#39;
    The public facing URL of the whole JupyterHub application.
    This is the address on which the proxy will bind. Sets protocol, ip,
    base_url
--ip=&lt;Unicode&gt; (JupyterHub.ip)
    Default: &#39;&#39;
    The public facing ip of the whole JupyterHub application (specifically
    referred to as the proxy).
    This is the address on which the proxy will listen. The default is to listen
    on all interfaces. This is the only address through which JupyterHub should
    be accessed by users.
    .. deprecated: 0.9
        Use JupyterHub.bind_url
--port=&lt;Int&gt; (JupyterHub.port)
    Default: 8000
    The public facing port of the proxy.
    This is the port on which the proxy will listen. This is the only port
    through which JupyterHub should be accessed by users.
    .. deprecated: 0.9
        Use JupyterHub.bind_url
--pid-file=&lt;Unicode&gt; (JupyterHub.pid_file)
    Default: &#39;&#39;
    File to write PID Useful for daemonizing JupyterHub.
--log-file=&lt;Unicode&gt; (JupyterHub.extra_log_file)
    Default: &#39;&#39;
    DEPRECATED: use output redirection instead, e.g.
    jupyterhub &amp;&gt;&gt; /var/log/jupyterhub.log
--log-level=&lt;Enum&gt; (Application.log_level)
    Default: 30
    Choices: (0, 10, 20, 30, 40, 50, &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARN&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;)
    Set the log level by value or name.
-f &lt;Unicode&gt; (JupyterHub.config_file)
    Default: &#39;jupyterhub_config.py&#39;
    The config file to load
--config=&lt;Unicode&gt; (JupyterHub.config_file)
    Default: &#39;jupyterhub_config.py&#39;
    The config file to load
--db=&lt;Unicode&gt; (JupyterHub.db_url)
    Default: &#39;sqlite:///jupyterhub.sqlite&#39;
    url for the database. e.g. `sqlite:///jupyterhub.sqlite`

Class parameters
----------------

Parameters are set from command-line arguments of the form:
`--Class.trait=value`. This line is evaluated in Python, so simple expressions
are allowed, e.g.:: `--C.a=&#39;range(3)&#39;` For setting C.a=[0,1,2].

JupyterHub options
------------------
--JupyterHub.active_server_limit=&lt;Int&gt;
    Default: 0
    Maximum number of concurrent servers that can be active at a time.
    Setting this can limit the total resources your users can consume.
    An active server is any server that&#39;s not fully stopped. It is considered
    active from the time it has been requested until the time that it has
    completely stopped.
    If this many user servers are active, users will not be able to launch new
    servers until a server is shutdown. Spawn requests will be rejected with a
    429 error asking them to try again.
    If set to 0, no limit is enforced.
--JupyterHub.active_user_window=&lt;Int&gt;
    Default: 1800
    Duration (in seconds) to determine the number of active users.
--JupyterHub.activity_resolution=&lt;Int&gt;
    Default: 30
    Resolution (in seconds) for updating activity
    If activity is registered that is less than activity_resolution seconds more
    recent than the current value, the new value will be ignored.
    This avoids too many writes to the Hub database.
--JupyterHub.admin_access=&lt;Bool&gt;
    Default: False
    Grant admin users permission to access single-user servers.
    Users should be properly informed if this is enabled.
--JupyterHub.admin_users=&lt;Set&gt;
    Default: set()
    DEPRECATED since version 0.7.2, use Authenticator.admin_users instead.
--JupyterHub.allow_named_servers=&lt;Bool&gt;
    Default: False
    Allow named single-user servers per user
--JupyterHub.answer_yes=&lt;Bool&gt;
    Default: False
    Answer yes to any questions (e.g. confirm overwrite)
--JupyterHub.api_tokens=&lt;Dict&gt;
    Default: {}
    PENDING DEPRECATION: consider using services
    Dict of token:username to be loaded into the database.
    Allows ahead-of-time generation of API tokens for use by externally managed
    services, which authenticate as JupyterHub users.
    Consider using services for general services that talk to the JupyterHub
    API.
--JupyterHub.authenticate_prometheus=&lt;Bool&gt;
    Default: True
    Authentication for prometheus metrics
--JupyterHub.authenticator_class=&lt;EntryPointType&gt;
    Default: &#39;jupyterhub.auth.PAMAuthenticator&#39;
    Class for authenticating users.
            This should be a subclass of :class:`jupyterhub.auth.Authenticator`
            with an :meth:`authenticate` method that:
            - is a coroutine (asyncio or tornado)
            - returns username on success, None on failure
            - takes two arguments: (handler, data),
              where `handler` is the calling web.RequestHandler,
              and `data` is the POST form data from the login page.
            .. versionchanged:: 1.0
                authenticators may be registered via entry points,
                e.g. `c.JupyterHub.authenticator_class = &#39;pam&#39;`
    Currently installed: 
      - default: jupyterhub.auth.PAMAuthenticator
      - dummy: jupyterhub.auth.DummyAuthenticator
      - pam: jupyterhub.auth.PAMAuthenticator
--JupyterHub.base_url=&lt;URLPrefix&gt;
    Default: &#39;/&#39;
    The base URL of the entire application.
    Add this to the beginning of all JupyterHub URLs. Use base_url to run
    JupyterHub within an existing website.
    .. deprecated: 0.9
        Use JupyterHub.bind_url
--JupyterHub.bind_url=&lt;Unicode&gt;
    Default: &#39;http://:8000&#39;
    The public facing URL of the whole JupyterHub application.
    This is the address on which the proxy will bind. Sets protocol, ip,
    base_url
--JupyterHub.cleanup_proxy=&lt;Bool&gt;
    Default: True
    Whether to shutdown the proxy when the Hub shuts down.
    Disable if you want to be able to teardown the Hub while leaving the proxy
    running.
    Only valid if the proxy was starting by the Hub process.
    If both this and cleanup_servers are False, sending SIGINT to the Hub will
    only shutdown the Hub, leaving everything else running.
    The Hub should be able to resume from database state.
--JupyterHub.cleanup_servers=&lt;Bool&gt;
    Default: True
    Whether to shutdown single-user servers when the Hub shuts down.
    Disable if you want to be able to teardown the Hub while leaving the single-
    user servers running.
    If both this and cleanup_proxy are False, sending SIGINT to the Hub will
    only shutdown the Hub, leaving everything else running.
    The Hub should be able to resume from database state.
--JupyterHub.concurrent_spawn_limit=&lt;Int&gt;
    Default: 100
    Maximum number of concurrent users that can be spawning at a time.
    Spawning lots of servers at the same time can cause performance problems for
    the Hub or the underlying spawning system. Set this limit to prevent bursts
    of logins from attempting to spawn too many servers at the same time.
    This does not limit the number of total running servers. See
    active_server_limit for that.
    If more than this many users attempt to spawn at a time, their requests will
    be rejected with a 429 error asking them to try again. Users will have to
    wait for some of the spawning services to finish starting before they can
    start their own.
    If set to 0, no limit is enforced.
--JupyterHub.config_file=&lt;Unicode&gt;
    Default: &#39;jupyterhub_config.py&#39;
    The config file to load
--JupyterHub.confirm_no_ssl=&lt;Bool&gt;
    Default: False
    DEPRECATED: does nothing
--JupyterHub.cookie_max_age_days=&lt;Float&gt;
    Default: 14
    Number of days for a login cookie to be valid. Default is two weeks.
--JupyterHub.cookie_secret=&lt;Bytes&gt;
    Default: b&#39;&#39;
    The cookie secret to use to encrypt cookies.
    Loaded from the JPY_COOKIE_SECRET env variable by default.
    Should be exactly 256 bits (32 bytes).
--JupyterHub.cookie_secret_file=&lt;Unicode&gt;
    Default: &#39;jupyterhub_cookie_secret&#39;
    File in which to store the cookie secret.
--JupyterHub.data_files_path=&lt;Unicode&gt;
    Default: &#39;$HOME/Development/python/workspace/jupyterhub/share/ju...
    The location of jupyterhub data files (e.g. /usr/local/share/jupyterhub)
--JupyterHub.db_kwargs=&lt;Dict&gt;
    Default: {}
    Include any kwargs to pass to the database connection. See
    sqlalchemy.create_engine for details.
--JupyterHub.db_url=&lt;Unicode&gt;
    Default: &#39;sqlite:///jupyterhub.sqlite&#39;
    url for the database. e.g. `sqlite:///jupyterhub.sqlite`
--JupyterHub.debug_db=&lt;Bool&gt;
    Default: False
    log all database transactions. This has A LOT of output
--JupyterHub.debug_proxy=&lt;Bool&gt;
    Default: False
    DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.debug
--JupyterHub.default_server_name=&lt;Unicode&gt;
    Default: &#39;&#39;
    If named servers are enabled, default name of server to spawn or open, e.g.
    by user-redirect.
--JupyterHub.default_url=&lt;Unicode&gt;
    Default: &#39;&#39;
    The default URL for users when they arrive (e.g. when user directs to &quot;/&quot;)
    By default, redirects users to their own server.
--JupyterHub.external_ssl_authorities=&lt;Dict&gt;
    Default: {}
    Dict authority:dict(files). Specify the key, cert, and/or ca file for an
    authority. This is useful for externally managed proxies that wish to use
    internal_ssl.
    The files dict has this format (you must specify at least a cert)::
        {
            &#39;key&#39;: &#39;/path/to/key.key&#39;,
            &#39;cert&#39;: &#39;/path/to/cert.crt&#39;,
            &#39;ca&#39;: &#39;/path/to/ca.crt&#39;
        }
    The authorities you can override: &#39;hub-ca&#39;, &#39;notebooks-ca&#39;, &#39;proxy-api-ca&#39;,
    &#39;proxy-client-ca&#39;, and &#39;services-ca&#39;.
    Use with internal_ssl
--JupyterHub.extra_handlers=&lt;List&gt;
    Default: []
    Register extra tornado Handlers for jupyterhub.
    Should be of the form ``(&quot;&lt;regex&gt;&quot;, Handler)``
    The Hub prefix will be added, so `/my-page` will be served at `/hub/my-
    page`.
--JupyterHub.extra_log_file=&lt;Unicode&gt;
    Default: &#39;&#39;
    DEPRECATED: use output redirection instead, e.g.
    jupyterhub &amp;&gt;&gt; /var/log/jupyterhub.log
--JupyterHub.extra_log_handlers=&lt;List&gt;
    Default: []
    Extra log handlers to set on JupyterHub logger
--JupyterHub.generate_certs=&lt;Bool&gt;
    Default: False
    Generate certs used for internal ssl
--JupyterHub.generate_config=&lt;Bool&gt;
    Default: False
    Generate default config file
--JupyterHub.hub_bind_url=&lt;Unicode&gt;
    Default: &#39;&#39;
    The URL on which the Hub will listen. This is a private URL for internal
    communication. Typically set in combination with hub_connect_url. If a unix
    socket, hub_connect_url **must** also be set.
    For example:
        &quot;http://127.0.0.1:8081&quot;
        &quot;unix+http://%2Fsrv%2Fjupyterhub%2Fjupyterhub.sock&quot;
    .. versionadded:: 0.9
--JupyterHub.hub_connect_ip=&lt;Unicode&gt;
    Default: &#39;&#39;
    The ip or hostname for proxies and spawners to use for connecting to the
    Hub.
    Use when the bind address (`hub_ip`) is 0.0.0.0, :: or otherwise different
    from the connect address.
    Default: when `hub_ip` is 0.0.0.0 or ::, use `socket.gethostname()`,
    otherwise use `hub_ip`.
    Note: Some spawners or proxy implementations might not support hostnames.
    Check your spawner or proxy documentation to see if they have extra
    requirements.
    .. versionadded:: 0.8
--JupyterHub.hub_connect_port=&lt;Int&gt;
    Default: 0
    DEPRECATED
    Use hub_connect_url
    .. versionadded:: 0.8
    .. deprecated:: 0.9
        Use hub_connect_url
--JupyterHub.hub_connect_url=&lt;Unicode&gt;
    Default: &#39;&#39;
    The URL for connecting to the Hub. Spawners, services, and the proxy will
    use this URL to talk to the Hub.
    Only needs to be specified if the default hub URL is not connectable (e.g.
    using a unix+http:// bind url).
    .. seealso::
        JupyterHub.hub_connect_ip
        JupyterHub.hub_bind_url
    .. versionadded:: 0.9
--JupyterHub.hub_ip=&lt;Unicode&gt;
    Default: &#39;127.0.0.1&#39;
    The ip address for the Hub process to *bind* to.
    By default, the hub listens on localhost only. This address must be
    accessible from the proxy and user servers. You may need to set this to a
    public ip or &#39;&#39; for all interfaces if the proxy or user servers are in
    containers or on a different host.
    See `hub_connect_ip` for cases where the bind and connect address should
    differ, or `hub_bind_url` for setting the full bind URL.
--JupyterHub.hub_port=&lt;Int&gt;
    Default: 8081
    The internal port for the Hub process.
    This is the internal port of the hub itself. It should never be accessed
    directly. See JupyterHub.port for the public port to use when accessing
    jupyterhub. It is rare that this port should be set except in cases of port
    conflict.
    See also `hub_ip` for the ip and `hub_bind_url` for setting the full bind
    URL.
--JupyterHub.implicit_spawn_seconds=&lt;Float&gt;
    Default: 0
    Trigger implicit spawns after this many seconds.
    When a user visits a URL for a server that&#39;s not running, they are shown a
    page indicating that the requested server is not running with a button to
    spawn the server.
    Setting this to a positive value will redirect the user after this many
    seconds, effectively clicking this button automatically for the users,
    automatically beginning the spawn process.
    Warning: this can result in errors and surprising behavior when sharing
    access URLs to actual servers, since the wrong server is likely to be
    started.
--JupyterHub.init_spawners_timeout=&lt;Int&gt;
    Default: 10
    Timeout (in seconds) to wait for spawners to initialize
    Checking if spawners are healthy can take a long time if many spawners are
    active at hub start time.
    If it takes longer than this timeout to check, init_spawner will be left to
    complete in the background and the http server is allowed to start.
    A timeout of -1 means wait forever, which can mean a slow startup of the Hub
    but ensures that the Hub is fully consistent by the time it starts
    responding to requests. This matches the behavior of jupyterhub 1.0.
    .. versionadded: 1.1.0
--JupyterHub.internal_certs_location=&lt;Unicode&gt;
    Default: &#39;internal-ssl&#39;
    The location to store certificates automatically created by JupyterHub.
    Use with internal_ssl
--JupyterHub.internal_ssl=&lt;Bool&gt;
    Default: False
    Enable SSL for all internal communication
    This enables end-to-end encryption between all JupyterHub components.
    JupyterHub will automatically create the necessary certificate authority and
    sign notebook certificates as they&#39;re created.
--JupyterHub.ip=&lt;Unicode&gt;
    Default: &#39;&#39;
    The public facing ip of the whole JupyterHub application (specifically
    referred to as the proxy).
    This is the address on which the proxy will listen. The default is to listen
    on all interfaces. This is the only address through which JupyterHub should
    be accessed by users.
    .. deprecated: 0.9
        Use JupyterHub.bind_url
--JupyterHub.jinja_environment_options=&lt;Dict&gt;
    Default: {}
    Supply extra arguments that will be passed to Jinja environment.
--JupyterHub.last_activity_interval=&lt;Int&gt;
    Default: 300
    Interval (in seconds) at which to update last-activity timestamps.
--JupyterHub.load_groups=&lt;Dict&gt;
    Default: {}
    Dict of &#39;group&#39;: [&#39;usernames&#39;] to load at startup.
    This strictly *adds* groups and users to groups.
    Loading one set of groups, then starting JupyterHub again with a different
    set will not remove users or groups from previous launches. That must be
    done through the API.
--JupyterHub.log_datefmt=&lt;Unicode&gt;
    Default: &#39;%Y-%m-%d %H:%M:%S&#39;
    The date format used by logging formatters for %(asctime)s
--JupyterHub.log_format=&lt;Unicode&gt;
    Default: &#39;[%(name)s]%(highlevel)s %(message)s&#39;
    The Logging format template
--JupyterHub.log_level=&lt;Enum&gt;
    Default: 30
    Choices: (0, 10, 20, 30, 40, 50, &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;WARN&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;)
    Set the log level by value or name.
--JupyterHub.logo_file=&lt;Unicode&gt;
    Default: &#39;&#39;
    Specify path to a logo image to override the Jupyter logo in the banner.
--JupyterHub.named_server_limit_per_user=&lt;Int&gt;
    Default: 0
    Maximum number of concurrent named servers that can be created by a user at
    a time.
    Setting this can limit the total resources a user can consume.
    If set to 0, no limit is enforced.
--JupyterHub.pid_file=&lt;Unicode&gt;
    Default: &#39;&#39;
    File to write PID Useful for daemonizing JupyterHub.
--JupyterHub.port=&lt;Int&gt;
    Default: 8000
    The public facing port of the proxy.
    This is the port on which the proxy will listen. This is the only port
    through which JupyterHub should be accessed by users.
    .. deprecated: 0.9
        Use JupyterHub.bind_url
--JupyterHub.proxy_api_ip=&lt;Unicode&gt;
    Default: &#39;&#39;
    DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url
--JupyterHub.proxy_api_port=&lt;Int&gt;
    Default: 0
    DEPRECATED since version 0.8 : Use ConfigurableHTTPProxy.api_url
--JupyterHub.proxy_auth_token=&lt;Unicode&gt;
    Default: &#39;&#39;
    DEPRECATED since version 0.8: Use ConfigurableHTTPProxy.auth_token
--JupyterHub.proxy_check_interval=&lt;Int&gt;
    Default: 30
    Interval (in seconds) at which to check if the proxy is running.
--JupyterHub.proxy_class=&lt;EntryPointType&gt;
    Default: &#39;jupyterhub.proxy.ConfigurableHTTPProxy&#39;
    The class to use for configuring the JupyterHub proxy.
            Should be a subclass of :class:`jupyterhub.proxy.Proxy`.
            .. versionchanged:: 1.0
                proxies may be registered via entry points,
                e.g. `c.JupyterHub.proxy_class = &#39;traefik&#39;`
    Currently installed: 
      - configurable-http-proxy: jupyterhub.proxy.ConfigurableHTTPProxy
      - default: jupyterhub.proxy.ConfigurableHTTPProxy
--JupyterHub.proxy_cmd=&lt;Command&gt;
    Default: []
    DEPRECATED since version 0.8. Use ConfigurableHTTPProxy.command
--JupyterHub.recreate_internal_certs=&lt;Bool&gt;
    Default: False
    Recreate all certificates used within JupyterHub on restart.
    Note: enabling this feature requires restarting all notebook servers.
    Use with internal_ssl
--JupyterHub.redirect_to_server=&lt;Bool&gt;
    Default: True
    Redirect user to server (if running), instead of control panel.
--JupyterHub.reset_db=&lt;Bool&gt;
    Default: False
    Purge and reset the database.
--JupyterHub.service_check_interval=&lt;Int&gt;
    Default: 60
    Interval (in seconds) at which to check connectivity of services with web
    endpoints.
--JupyterHub.service_tokens=&lt;Dict&gt;
    Default: {}
    Dict of token:servicename to be loaded into the database.
    Allows ahead-of-time generation of API tokens for use by externally managed
    services.
--JupyterHub.services=&lt;List&gt;
    Default: []
    List of service specification dictionaries.
    A service
    For instance::
        services = [
            {
                &#39;name&#39;: &#39;cull_idle&#39;,
                &#39;command&#39;: [&#39;/path/to/cull_idle_servers.py&#39;],
            },
            {
                &#39;name&#39;: &#39;formgrader&#39;,
                &#39;url&#39;: &#39;http://127.0.0.1:1234&#39;,
                &#39;api_token&#39;: &#39;super-secret&#39;,
                &#39;environment&#39;:
            }
        ]
--JupyterHub.shutdown_on_logout=&lt;Bool&gt;
    Default: False
    Shuts down all user servers on logout
--JupyterHub.spawner_class=&lt;EntryPointType&gt;
    Default: &#39;jupyterhub.spawner.LocalProcessSpawner&#39;
    The class to use for spawning single-user servers.
            Should be a subclass of :class:`jupyterhub.spawner.Spawner`.
            .. versionchanged:: 1.0
                spawners may be registered via entry points,
                e.g. `c.JupyterHub.spawner_class = &#39;localprocess&#39;`
    Currently installed: 
      - default: jupyterhub.spawner.LocalProcessSpawner
      - localprocess: jupyterhub.spawner.LocalProcessSpawner
      - simple: jupyterhub.spawner.SimpleLocalProcessSpawner
--JupyterHub.ssl_cert=&lt;Unicode&gt;
    Default: &#39;&#39;
    Path to SSL certificate file for the public facing interface of the proxy
    When setting this, you should also set ssl_key
--JupyterHub.ssl_key=&lt;Unicode&gt;
    Default: &#39;&#39;
    Path to SSL key file for the public facing interface of the proxy
    When setting this, you should also set ssl_cert
--JupyterHub.statsd_host=&lt;Unicode&gt;
    Default: &#39;&#39;
    Host to send statsd metrics to. An empty string (the default) disables
    sending metrics.
--JupyterHub.statsd_port=&lt;Int&gt;
    Default: 8125
    Port on which to send statsd metrics about the hub
--JupyterHub.statsd_prefix=&lt;Unicode&gt;
    Default: &#39;jupyterhub&#39;
    Prefix to use for all metrics sent by jupyterhub to statsd
--JupyterHub.subdomain_host=&lt;Unicode&gt;
    Default: &#39;&#39;
    Run single-user servers on subdomains of this host.
    This should be the full `https://hub.domain.tld[:port]`.
    Provides additional cross-site protections for javascript served by single-
    user servers.
    Requires `&lt;username&gt;.hub.domain.tld` to resolve to the same host as
    `hub.domain.tld`.
    In general, this is most easily achieved with wildcard DNS.
    When using SSL (i.e. always) this also requires a wildcard SSL certificate.
--JupyterHub.template_paths=&lt;List&gt;
    Default: []
    Paths to search for jinja templates, before using the default templates.
--JupyterHub.template_vars=&lt;Dict&gt;
    Default: {}
    Extra variables to be passed into jinja templates
--JupyterHub.tornado_settings=&lt;Dict&gt;
    Default: {}
    Extra settings overrides to pass to the tornado application.
--JupyterHub.trust_user_provided_tokens=&lt;Bool&gt;
    Default: False
    Trust user-provided tokens (via JupyterHub.service_tokens) to have good
    entropy.
    If you are not inserting additional tokens via configuration file, this flag
    has no effect.
    In JupyterHub 0.8, internally generated tokens do not pass through
    additional hashing because the hashing is costly and does not increase the
    entropy of already-good UUIDs.
    User-provided tokens, on the other hand, are not trusted to have good
    entropy by default, and are passed through many rounds of hashing to stretch
    the entropy of the key (i.e. user-provided tokens are treated as passwords
    instead of random keys). These keys are more costly to check.
    If your inserted tokens are generated by a good-quality mechanism, e.g.
    `openssl rand -hex 32`, then you can set this flag to True to reduce the
    cost of checking authentication tokens.
--JupyterHub.trusted_alt_names=&lt;List&gt;
    Default: []
    Names to include in the subject alternative name.
    These names will be used for server name verification. This is useful if
    JupyterHub is being run behind a reverse proxy or services using ssl are on
    different hosts.
    Use with internal_ssl
--JupyterHub.trusted_downstream_ips=&lt;List&gt;
    Default: []
    Downstream proxy IP addresses to trust.
    This sets the list of IP addresses that are trusted and skipped when
    processing the `X-Forwarded-For` header. For example, if an external proxy
    is used for TLS termination, its IP address should be added to this list to
    ensure the correct client IP addresses are recorded in the logs instead of
    the proxy server&#39;s IP address.
--JupyterHub.upgrade_db=&lt;Bool&gt;
    Default: False
    Upgrade the database automatically on start.
    Only safe if database is regularly backed up. Only SQLite databases will be
    backed up to a local file automatically.
--JupyterHub.user_redirect_hook=&lt;Callable&gt;
    Default: None
    Callable to affect behavior of /user-redirect/
    Receives 4 parameters: 1. path - URL path that was provided after /user-
    redirect/ 2. request - A Tornado HTTPServerRequest representing the current
    request. 3. user - The currently authenticated user. 4. base_url - The
    base_url of the current hub, for relative redirects
    It should return the new URL to redirect to, or None to preserve current
    behavior.

Spawner options
---------------
--Spawner.args=&lt;List&gt;
    Default: []
    Extra arguments to be passed to the single-user server.
    Some spawners allow shell-style expansion here, allowing you to use
    environment variables here. Most, including the default, do not. Consult the
    documentation for your spawner to verify!
--Spawner.auth_state_hook=&lt;Any&gt;
    Default: None
    An optional hook function that you can implement to pass `auth_state` to the
    spawner after it has been initialized but before it starts. The `auth_state`
    dictionary may be set by the `.authenticate()` method of the authenticator.
    This hook enables you to pass some or all of that information to your
    spawner.
    Example::
        def userdata_hook(spawner, auth_state):
            spawner.userdata = auth_state[&quot;userdata&quot;]
        c.Spawner.auth_state_hook = userdata_hook
--Spawner.cmd=&lt;Command&gt;
    Default: [&#39;jupyterhub-singleuser&#39;]
    The command used for starting the single-user server.
    Provide either a string or a list containing the path to the startup script
    command. Extra arguments, other than this path, should be provided via
    `args`.
    This is usually set if you want to start the single-user server in a
    different python environment (with virtualenv/conda) than JupyterHub itself.
    Some spawners allow shell-style expansion here, allowing you to use
    environment variables. Most, including the default, do not. Consult the
    documentation for your spawner to verify!
--Spawner.consecutive_failure_limit=&lt;Int&gt;
    Default: 0
    Maximum number of consecutive failures to allow before shutting down
    JupyterHub.
    This helps JupyterHub recover from a certain class of problem preventing
    launch in contexts where the Hub is automatically restarted (e.g. systemd,
    docker, kubernetes).
    A limit of 0 means no limit and consecutive failures will not be tracked.
--Spawner.cpu_guarantee=&lt;Float&gt;
    Default: None
    Minimum number of cpu-cores a single-user notebook server is guaranteed to
    have available.
    If this value is set to 0.5, allows use of 50% of one CPU. If this value is
    set to 2, allows use of up to 2 CPUs.
    **This is a configuration setting. Your spawner must implement support for
    the limit to work.** The default spawner, `LocalProcessSpawner`, does
    **not** implement this support. A custom spawner **must** add support for
    this setting for it to be enforced.
--Spawner.cpu_limit=&lt;Float&gt;
    Default: None
    Maximum number of cpu-cores a single-user notebook server is allowed to use.
    If this value is set to 0.5, allows use of 50% of one CPU. If this value is
    set to 2, allows use of up to 2 CPUs.
    The single-user notebook server will never be scheduled by the kernel to use
    more cpu-cores than this. There is no guarantee that it can access this many
    cpu-cores.
    **This is a configuration setting. Your spawner must implement support for
    the limit to work.** The default spawner, `LocalProcessSpawner`, does
    **not** implement this support. A custom spawner **must** add support for
    this setting for it to be enforced.
--Spawner.debug=&lt;Bool&gt;
    Default: False
    Enable debug-logging of the single-user server
--Spawner.default_url=&lt;Unicode&gt;
    Default: &#39;&#39;
    The URL the single-user server should start in.
    `{username}` will be expanded to the user&#39;s username
    Example uses:
    - You can set `notebook_dir` to `/` and `default_url` to `/tree/home/{username}` to allow people to
      navigate the whole filesystem from their notebook server, but still start in their home directory.
    - Start with `/notebooks` instead of `/tree` if `default_url` points to a notebook instead of a directory.
    - You can set this to `/lab` to have JupyterLab start by default, rather than Jupyter Notebook.
--Spawner.disable_user_config=&lt;Bool&gt;
    Default: False
    Disable per-user configuration of single-user servers.
    When starting the user&#39;s single-user server, any config file found in the
    user&#39;s $HOME directory will be ignored.
    Note: a user could circumvent this if the user modifies their Python
    environment, such as when they have their own conda environments /
    virtualenvs / containers.
--Spawner.env_keep=&lt;List&gt;
    Default: [&#39;PATH&#39;, &#39;PYTHONPATH&#39;, &#39;CONDA_ROOT&#39;, &#39;CONDA_DEFAULT_ENV&#39;, &#39;VI...
    Whitelist of environment variables for the single-user server to inherit
    from the JupyterHub process.
    This whitelist is used to ensure that sensitive information in the
    JupyterHub process&#39;s environment (such as `CONFIGPROXY_AUTH_TOKEN`) is not
    passed to the single-user server&#39;s process.
--Spawner.environment=&lt;Dict&gt;
    Default: {}
    Extra environment variables to set for the single-user server&#39;s process.
    Environment variables that end up in the single-user server&#39;s process come from 3 sources:
      - This `environment` configurable
      - The JupyterHub process&#39; environment variables that are whitelisted in `env_keep`
      - Variables to establish contact between the single-user notebook and the hub (such as JUPYTERHUB_API_TOKEN)
    The `environment` configurable should be set by JupyterHub administrators to
    add installation specific environment variables. It is a dict where the key
    is the name of the environment variable, and the value can be a string or a
    callable. If it is a callable, it will be called with one parameter (the
    spawner instance), and should return a string fairly quickly (no blocking
    operations please!).
    Note that the spawner class&#39; interface is not guaranteed to be exactly same
    across upgrades, so if you are using the callable take care to verify it
    continues to work after upgrades!
--Spawner.http_timeout=&lt;Int&gt;
    Default: 30
    Timeout (in seconds) before giving up on a spawned HTTP server
    Once a server has successfully been spawned, this is the amount of time we
    wait before assuming that the server is unable to accept connections.
--Spawner.ip=&lt;Unicode&gt;
    Default: &#39;&#39;
    The IP address (or hostname) the single-user server should listen on.
    The JupyterHub proxy implementation should be able to send packets to this
    interface.
--Spawner.mem_guarantee=&lt;ByteSpecification&gt;
    Default: None
    Minimum number of bytes a single-user notebook server is guaranteed to have
    available.
    Allows the following suffixes:
      - K -&gt; Kilobytes
      - M -&gt; Megabytes
      - G -&gt; Gigabytes
      - T -&gt; Terabytes
    **This is a configuration setting. Your spawner must implement support for
    the limit to work.** The default spawner, `LocalProcessSpawner`, does
    **not** implement this support. A custom spawner **must** add support for
    this setting for it to be enforced.
--Spawner.mem_limit=&lt;ByteSpecification&gt;
    Default: None
    Maximum number of bytes a single-user notebook server is allowed to use.
    Allows the following suffixes:
      - K -&gt; Kilobytes
      - M -&gt; Megabytes
      - G -&gt; Gigabytes
      - T -&gt; Terabytes
    If the single user server tries to allocate more memory than this, it will
    fail. There is no guarantee that the single-user notebook server will be
    able to allocate this much memory - only that it can not allocate more than
    this.
    **This is a configuration setting. Your spawner must implement support for
    the limit to work.** The default spawner, `LocalProcessSpawner`, does
    **not** implement this support. A custom spawner **must** add support for
    this setting for it to be enforced.
--Spawner.notebook_dir=&lt;Unicode&gt;
    Default: &#39;&#39;
    Path to the notebook directory for the single-user server.
    The user sees a file listing of this directory when the notebook interface
    is started. The current interface does not easily allow browsing beyond the
    subdirectories in this directory&#39;s tree.
    `~` will be expanded to the home directory of the user, and {username} will
    be replaced with the name of the user.
    Note that this does *not* prevent users from accessing files outside of this
    path! They can do so with many other means.
--Spawner.options_form=&lt;Union&gt;
    Default: traitlets.Undefined
    An HTML form for options a user can specify on launching their server.
    The surrounding `&lt;form&gt;` element and the submit button are already provided.
    For example:
    .. code:: html
        Set your key:
        &lt;input name=&quot;key&quot; val=&quot;default_key&quot;&gt;&lt;/input&gt;
        &lt;br&gt;
        Choose a letter:
        &lt;select name=&quot;letter&quot; multiple=&quot;true&quot;&gt;
          &lt;option value=&quot;A&quot;&gt;The letter A&lt;/option&gt;
          &lt;option value=&quot;B&quot;&gt;The letter B&lt;/option&gt;
        &lt;/select&gt;
    The data from this form submission will be passed on to your spawner in
    `self.user_options`
    Instead of a form snippet string, this could also be a callable that takes
    as one parameter the current spawner instance and returns a string. The
    callable will be called asynchronously if it returns a future, rather than a
    str. Note that the interface of the spawner class is not deemed stable
    across versions, so using this functionality might cause your JupyterHub
    upgrades to break.
--Spawner.poll_interval=&lt;Int&gt;
    Default: 30
    Interval (in seconds) on which to poll the spawner for single-user server&#39;s
    status.
    At every poll interval, each spawner&#39;s `.poll` method is called, which
    checks if the single-user server is still running. If it isn&#39;t running, then
    JupyterHub modifies its own state accordingly and removes appropriate routes
    from the configurable proxy.
--Spawner.port=&lt;Int&gt;
    Default: 0
    The port for single-user servers to listen on.
    Defaults to `0`, which uses a randomly allocated port number each time.
    If set to a non-zero value, all Spawners will use the same port, which only
    makes sense if each server is on a different address, e.g. in containers.
    New in version 0.7.
--Spawner.post_stop_hook=&lt;Any&gt;
    Default: None
    An optional hook function that you can implement to do work after the
    spawner stops.
    This can be set independent of any concrete spawner implementation.
--Spawner.pre_spawn_hook=&lt;Any&gt;
    Default: None
    An optional hook function that you can implement to do some bootstrapping
    work before the spawner starts. For example, create a directory for your
    user or load initial content.
    This can be set independent of any concrete spawner implementation.
    This maybe a coroutine.
    Example::
        from subprocess import check_call
        def my_hook(spawner):
            username = spawner.user.name
            check_call([&#39;./examples/bootstrap-script/bootstrap.sh&#39;, username])
        c.Spawner.pre_spawn_hook = my_hook
--Spawner.ssl_alt_names=&lt;List&gt;
    Default: []
    List of SSL alt names
    May be set in config if all spawners should have the same value(s), or set
    at runtime by Spawner that know their names.
--Spawner.ssl_alt_names_include_local=&lt;Bool&gt;
    Default: True
    Whether to include DNS:localhost, IP:127.0.0.1 in alt names
--Spawner.start_timeout=&lt;Int&gt;
    Default: 60
    Timeout (in seconds) before giving up on starting of single-user server.
    This is the timeout for start to return, not the timeout for the server to
    respond. Callers of spawner.start will assume that startup has failed if it
    takes longer than this. start should return when the server process is
    started and its location is known.

Authenticator options
---------------------
--Authenticator.admin_users=&lt;Set&gt;
    Default: set()
    Set of users that will have admin rights on this JupyterHub.
    Admin users have extra privileges:
     - Use the admin panel to see list of users logged in
     - Add / remove users in some authenticators
     - Restart / halt the hub
     - Start / stop users&#39; single-user servers
     - Can access each individual users&#39; single-user server (if configured)
    Admin access should be treated the same way root access is.
    Defaults to an empty set, in which case no user has admin access.
--Authenticator.auth_refresh_age=&lt;Int&gt;
    Default: 300
    The max age (in seconds) of authentication info before forcing a refresh of
    user auth info.
    Refreshing auth info allows, e.g. requesting/re-validating auth tokens.
    See :meth:`.refresh_user` for what happens when user auth info is refreshed
    (nothing by default).
--Authenticator.auto_login=&lt;Bool&gt;
    Default: False
    Automatically begin the login process
    rather than starting with a &quot;Login with...&quot; link at `/hub/login`
    To work, `.login_url()` must give a URL other than the default `/hub/login`,
    such as an oauth handler or another automatic login handler, registered with
    `.get_handlers()`.
    .. versionadded:: 0.8
--Authenticator.blacklist=&lt;Set&gt;
    Default: set()
    Blacklist of usernames that are not allowed to log in.
    Use this with supported authenticators to restrict which users can not log
    in. This is an additional blacklist that further restricts users, beyond
    whatever restrictions the authenticator has in place.
    If empty, does not perform any additional restriction.
    .. versionadded: 0.9
--Authenticator.enable_auth_state=&lt;Bool&gt;
    Default: False
    Enable persisting auth_state (if available).
    auth_state will be encrypted and stored in the Hub&#39;s database. This can
    include things like authentication tokens, etc. to be passed to Spawners as
    environment variables.
    Encrypting auth_state requires the cryptography package.
    Additionally, the JUPYTERHUB_CRYPT_KEY environment variable must contain one
    (or more, separated by ;) 32B encryption keys. These can be either base64 or
    hex-encoded.
    If encryption is unavailable, auth_state cannot be persisted.
    New in JupyterHub 0.8
--Authenticator.post_auth_hook=&lt;Any&gt;
    Default: None
    An optional hook function that you can implement to do some bootstrapping
    work during authentication. For example, loading user account details from
    an external system.
    This function is called after the user has passed all authentication checks
    and is ready to successfully authenticate. This function must return the
    authentication dict reguardless of changes to it.
    This maybe a coroutine.
    .. versionadded: 1.0
    Example::
        import os, pwd
        def my_hook(authenticator, handler, authentication):
            user_data = pwd.getpwnam(authentication[&#39;name&#39;])
            spawn_data = {
                &#39;pw_data&#39;: user_data
                &#39;gid_list&#39;: os.getgrouplist(authentication[&#39;name&#39;], user_data.pw_gid)
            }
            if authentication[&#39;auth_state&#39;] is None:
                authentication[&#39;auth_state&#39;] = {}
            authentication[&#39;auth_state&#39;][&#39;spawn_data&#39;] = spawn_data
            return authentication
        c.Authenticator.post_auth_hook = my_hook
--Authenticator.refresh_pre_spawn=&lt;Bool&gt;
    Default: False
    Force refresh of auth prior to spawn.
    This forces :meth:`.refresh_user` to be called prior to launching a server,
    to ensure that auth state is up-to-date.
    This can be important when e.g. auth tokens that may have expired are passed
    to the spawner via environment variables from auth_state.
    If refresh_user cannot refresh the user auth data, launch will fail until
    the user logs in again.
--Authenticator.username_map=&lt;Dict&gt;
    Default: {}
    Dictionary mapping authenticator usernames to JupyterHub users.
    Primarily used to normalize OAuth user names to local users.
--Authenticator.username_pattern=&lt;Unicode&gt;
    Default: &#39;&#39;
    Regular expression pattern that all valid usernames must match.
    If a username does not match the pattern specified here, authentication will
    not be attempted.
    If not set, allow any username.
--Authenticator.whitelist=&lt;Set&gt;
    Default: set()
    Whitelist of usernames that are allowed to log in.
    Use this with supported authenticators to restrict which users can log in.
    This is an additional whitelist that further restricts users, beyond
    whatever restrictions the authenticator has in place.
    If empty, does not perform any additional restriction.

CryptKeeper options
-------------------
--CryptKeeper.keys=&lt;List&gt;
    Default: []
--CryptKeeper.n_threads=&lt;Int&gt;
    Default: 8
    The number of threads to allocate for encryption

Examples
--------

    generate default config file:
    
        jupyterhub --generate-config -f /etc/jupyterhub/jupyterhub_config.py
    
    spawn the server on 10.0.1.2:443 with https:
    
        jupyterhub --ip 10.0.1.2 --port 443 --ssl-key my_ssl.key --ssl-cert my_ssl.cert

</pre></div>
</div>
</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="config-sudo.html" title="previous page">Run JupyterHub without root privileges using <code class="docutils literal notranslate"><span class="pre">sudo</span></code></a>
    <a class='right-next' id="next-link" href="../index-admin.html" title="next page">Administrator’s Guide</a>

              </div>
              
          </main>
          

      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2016, Project Jupyter team.<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>